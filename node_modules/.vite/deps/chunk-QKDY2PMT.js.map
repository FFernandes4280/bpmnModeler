{
  "version": 3,
  "sources": ["../../min-dash/dist/index.esm.js", "../../moddle/lib/base.js", "../../moddle/lib/factory.js", "../../moddle/lib/types.js", "../../moddle/lib/ns.js", "../../moddle/lib/descriptor-builder.js", "../../moddle/lib/registry.js", "../../moddle/lib/properties.js", "../../moddle/lib/moddle.js", "../../saxen/lib/decode.js", "../../saxen/lib/parser.js", "../../moddle-xml/lib/common.js", "../../moddle-xml/lib/read.js", "../../moddle-xml/lib/write.js", "../../bpmn-moddle/lib/bpmn-moddle.js", "../../bpmn-moddle/lib/simple.js"],
  "sourcesContent": ["/**\n * Flatten array, one level deep.\n *\n * @template T\n *\n * @param {T[][] | T[] | null} [arr]\n *\n * @return {T[]}\n */\nfunction flatten(arr) {\n  return Array.prototype.concat.apply([], arr);\n}\n\nconst nativeToString = Object.prototype.toString;\nconst nativeHasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction isUndefined(obj) {\n  return obj === undefined;\n}\n\nfunction isDefined(obj) {\n  return obj !== undefined;\n}\n\nfunction isNil(obj) {\n  return obj == null;\n}\n\nfunction isArray(obj) {\n  return nativeToString.call(obj) === '[object Array]';\n}\n\nfunction isObject(obj) {\n  return nativeToString.call(obj) === '[object Object]';\n}\n\nfunction isNumber(obj) {\n  return nativeToString.call(obj) === '[object Number]';\n}\n\n/**\n * @param {any} obj\n *\n * @return {boolean}\n */\nfunction isFunction(obj) {\n  const tag = nativeToString.call(obj);\n\n  return (\n    tag === '[object Function]' ||\n    tag === '[object AsyncFunction]' ||\n    tag === '[object GeneratorFunction]' ||\n    tag === '[object AsyncGeneratorFunction]' ||\n    tag === '[object Proxy]'\n  );\n}\n\nfunction isString(obj) {\n  return nativeToString.call(obj) === '[object String]';\n}\n\n\n/**\n * Ensure collection is an array.\n *\n * @param {Object} obj\n */\nfunction ensureArray(obj) {\n\n  if (isArray(obj)) {\n    return;\n  }\n\n  throw new Error('must supply array');\n}\n\n/**\n * Return true, if target owns a property with the given key.\n *\n * @param {Object} target\n * @param {String} key\n *\n * @return {Boolean}\n */\nfunction has(target, key) {\n  return !isNil(target) && nativeHasOwnProperty.call(target, key);\n}\n\n/**\n * @template T\n * @typedef { (\n *   ((e: T) => boolean) |\n *   ((e: T, idx: number) => boolean) |\n *   ((e: T, key: string) => boolean) |\n *   string |\n *   number\n * ) } Matcher\n */\n\n/**\n * @template T\n * @template U\n *\n * @typedef { (\n *   ((e: T) => U) | string | number\n * ) } Extractor\n */\n\n\n/**\n * @template T\n * @typedef { (val: T, key: any) => boolean } MatchFn\n */\n\n/**\n * @template T\n * @typedef { T[] } ArrayCollection\n */\n\n/**\n * @template T\n * @typedef { { [key: string]: T } } StringKeyValueCollection\n */\n\n/**\n * @template T\n * @typedef { { [key: number]: T } } NumberKeyValueCollection\n */\n\n/**\n * @template T\n * @typedef { StringKeyValueCollection<T> | NumberKeyValueCollection<T> } KeyValueCollection\n */\n\n/**\n * @template T\n * @typedef { KeyValueCollection<T> | ArrayCollection<T> } Collection\n */\n\n/**\n * Find element in collection.\n *\n * @template T\n * @param {Collection<T>} collection\n * @param {Matcher<T>} matcher\n *\n * @return {Object}\n */\nfunction find(collection, matcher) {\n\n  const matchFn = toMatcher(matcher);\n\n  let match;\n\n  forEach(collection, function(val, key) {\n    if (matchFn(val, key)) {\n      match = val;\n\n      return false;\n    }\n  });\n\n  return match;\n\n}\n\n\n/**\n * Find element index in collection.\n *\n * @template T\n * @param {Collection<T>} collection\n * @param {Matcher<T>} matcher\n *\n * @return {number | string | undefined}\n */\nfunction findIndex(collection, matcher) {\n\n  const matchFn = toMatcher(matcher);\n\n  let idx = isArray(collection) ? -1 : undefined;\n\n  forEach(collection, function(val, key) {\n    if (matchFn(val, key)) {\n      idx = key;\n\n      return false;\n    }\n  });\n\n  return idx;\n}\n\n\n/**\n * Filter elements in collection.\n *\n * @template T\n * @param {Collection<T>} collection\n * @param {Matcher<T>} matcher\n *\n * @return {T[]} result\n */\nfunction filter(collection, matcher) {\n\n  const matchFn = toMatcher(matcher);\n\n  let result = [];\n\n  forEach(collection, function(val, key) {\n    if (matchFn(val, key)) {\n      result.push(val);\n    }\n  });\n\n  return result;\n}\n\n\n/**\n * Iterate over collection; returning something\n * (non-undefined) will stop iteration.\n *\n * @template T\n * @param {Collection<T>} collection\n * @param { ((item: T, idx: number) => (boolean|void)) | ((item: T, key: string) => (boolean|void)) } iterator\n *\n * @return {T} return result that stopped the iteration\n */\nfunction forEach(collection, iterator) {\n\n  let val,\n      result;\n\n  if (isUndefined(collection)) {\n    return;\n  }\n\n  const convertKey = isArray(collection) ? toNum : identity;\n\n  for (let key in collection) {\n\n    if (has(collection, key)) {\n      val = collection[key];\n\n      result = iterator(val, convertKey(key));\n\n      if (result === false) {\n        return val;\n      }\n    }\n  }\n}\n\n/**\n * Return collection without element.\n *\n * @template T\n * @param {ArrayCollection<T>} arr\n * @param {Matcher<T>} matcher\n *\n * @return {T[]}\n */\nfunction without(arr, matcher) {\n\n  if (isUndefined(arr)) {\n    return [];\n  }\n\n  ensureArray(arr);\n\n  const matchFn = toMatcher(matcher);\n\n  return arr.filter(function(el, idx) {\n    return !matchFn(el, idx);\n  });\n\n}\n\n\n/**\n * Reduce collection, returning a single result.\n *\n * @template T\n * @template V\n *\n * @param {Collection<T>} collection\n * @param {(result: V, entry: T, index: any) => V} iterator\n * @param {V} result\n *\n * @return {V} result returned from last iterator\n */\nfunction reduce(collection, iterator, result) {\n\n  forEach(collection, function(value, idx) {\n    result = iterator(result, value, idx);\n  });\n\n  return result;\n}\n\n\n/**\n * Return true if every element in the collection\n * matches the criteria.\n *\n * @param  {Object|Array} collection\n * @param  {Function} matcher\n *\n * @return {Boolean}\n */\nfunction every(collection, matcher) {\n\n  return !!reduce(collection, function(matches, val, key) {\n    return matches && matcher(val, key);\n  }, true);\n}\n\n\n/**\n * Return true if some elements in the collection\n * match the criteria.\n *\n * @param  {Object|Array} collection\n * @param  {Function} matcher\n *\n * @return {Boolean}\n */\nfunction some(collection, matcher) {\n\n  return !!find(collection, matcher);\n}\n\n\n/**\n * Transform a collection into another collection\n * by piping each member through the given fn.\n *\n * @param  {Object|Array}   collection\n * @param  {Function} fn\n *\n * @return {Array} transformed collection\n */\nfunction map(collection, fn) {\n\n  let result = [];\n\n  forEach(collection, function(val, key) {\n    result.push(fn(val, key));\n  });\n\n  return result;\n}\n\n\n/**\n * Get the collections keys.\n *\n * @param  {Object|Array} collection\n *\n * @return {Array}\n */\nfunction keys(collection) {\n  return collection && Object.keys(collection) || [];\n}\n\n\n/**\n * Shorthand for `keys(o).length`.\n *\n * @param  {Object|Array} collection\n *\n * @return {Number}\n */\nfunction size(collection) {\n  return keys(collection).length;\n}\n\n\n/**\n * Get the values in the collection.\n *\n * @param  {Object|Array} collection\n *\n * @return {Array}\n */\nfunction values(collection) {\n  return map(collection, (val) => val);\n}\n\n\n/**\n * Group collection members by attribute.\n *\n * @param {Object|Array} collection\n * @param {Extractor} extractor\n *\n * @return {Object} map with { attrValue => [ a, b, c ] }\n */\nfunction groupBy(collection, extractor, grouped = {}) {\n\n  extractor = toExtractor(extractor);\n\n  forEach(collection, function(val) {\n    let discriminator = extractor(val) || '_';\n\n    let group = grouped[discriminator];\n\n    if (!group) {\n      group = grouped[discriminator] = [];\n    }\n\n    group.push(val);\n  });\n\n  return grouped;\n}\n\n\nfunction uniqueBy(extractor, ...collections) {\n\n  extractor = toExtractor(extractor);\n\n  let grouped = {};\n\n  forEach(collections, (c) => groupBy(c, extractor, grouped));\n\n  let result = map(grouped, function(val, key) {\n    return val[0];\n  });\n\n  return result;\n}\n\n\nconst unionBy = uniqueBy;\n\n\n\n/**\n * Sort collection by criteria.\n *\n * @template T\n *\n * @param {Collection<T>} collection\n * @param {Extractor<T, number | string>} extractor\n *\n * @return {Array}\n */\nfunction sortBy(collection, extractor) {\n\n  extractor = toExtractor(extractor);\n\n  let sorted = [];\n\n  forEach(collection, function(value, key) {\n    let disc = extractor(value, key);\n\n    let entry = {\n      d: disc,\n      v: value\n    };\n\n    for (var idx = 0; idx < sorted.length; idx++) {\n      let { d } = sorted[idx];\n\n      if (disc < d) {\n        sorted.splice(idx, 0, entry);\n        return;\n      }\n    }\n\n    // not inserted, append (!)\n    sorted.push(entry);\n  });\n\n  return map(sorted, (e) => e.v);\n}\n\n\n/**\n * Create an object pattern matcher.\n *\n * @example\n *\n * ```javascript\n * const matcher = matchPattern({ id: 1 });\n *\n * let element = find(elements, matcher);\n * ```\n *\n * @template T\n *\n * @param {T} pattern\n *\n * @return { (el: any) =>  boolean } matcherFn\n */\nfunction matchPattern(pattern) {\n\n  return function(el) {\n\n    return every(pattern, function(val, key) {\n      return el[key] === val;\n    });\n\n  };\n}\n\n\n/**\n * @param {string | ((e: any) => any) } extractor\n *\n * @return { (e: any) => any }\n */\nfunction toExtractor(extractor) {\n\n  /**\n   * @satisfies { (e: any) => any }\n   */\n  return isFunction(extractor) ? extractor : (e) => {\n\n    // @ts-ignore: just works\n    return e[extractor];\n  };\n}\n\n\n/**\n * @template T\n * @param {Matcher<T>} matcher\n *\n * @return {MatchFn<T>}\n */\nfunction toMatcher(matcher) {\n  return isFunction(matcher) ? matcher : (e) => {\n    return e === matcher;\n  };\n}\n\n\nfunction identity(arg) {\n  return arg;\n}\n\nfunction toNum(arg) {\n  return Number(arg);\n}\n\n/* global setTimeout clearTimeout */\n\n/**\n * @typedef { {\n *   (...args: any[]): any;\n *   flush: () => void;\n *   cancel: () => void;\n * } } DebouncedFunction\n */\n\n/**\n * Debounce fn, calling it only once if the given time\n * elapsed between calls.\n *\n * Lodash-style the function exposes methods to `#clear`\n * and `#flush` to control internal behavior.\n *\n * @param  {Function} fn\n * @param  {Number} timeout\n *\n * @return {DebouncedFunction} debounced function\n */\nfunction debounce(fn, timeout) {\n\n  let timer;\n\n  let lastArgs;\n  let lastThis;\n\n  let lastNow;\n\n  function fire(force) {\n\n    let now = Date.now();\n\n    let scheduledDiff = force ? 0 : (lastNow + timeout) - now;\n\n    if (scheduledDiff > 0) {\n      return schedule(scheduledDiff);\n    }\n\n    fn.apply(lastThis, lastArgs);\n\n    clear();\n  }\n\n  function schedule(timeout) {\n    timer = setTimeout(fire, timeout);\n  }\n\n  function clear() {\n    if (timer) {\n      clearTimeout(timer);\n    }\n\n    timer = lastNow = lastArgs = lastThis = undefined;\n  }\n\n  function flush() {\n    if (timer) {\n      fire(true);\n    }\n\n    clear();\n  }\n\n  /**\n   * @type { DebouncedFunction }\n   */\n  function callback(...args) {\n    lastNow = Date.now();\n\n    lastArgs = args;\n    lastThis = this;\n\n    // ensure an execution is scheduled\n    if (!timer) {\n      schedule(timeout);\n    }\n  }\n\n  callback.flush = flush;\n  callback.cancel = clear;\n\n  return callback;\n}\n\n/**\n * Throttle fn, calling at most once\n * in the given interval.\n *\n * @param  {Function} fn\n * @param  {Number} interval\n *\n * @return {Function} throttled function\n */\nfunction throttle(fn, interval) {\n  let throttling = false;\n\n  return function(...args) {\n\n    if (throttling) {\n      return;\n    }\n\n    fn(...args);\n    throttling = true;\n\n    setTimeout(() => {\n      throttling = false;\n    }, interval);\n  };\n}\n\n/**\n * Bind function against target <this>.\n *\n * @param  {Function} fn\n * @param  {Object}   target\n *\n * @return {Function} bound function\n */\nfunction bind(fn, target) {\n  return fn.bind(target);\n}\n\n/**\n * Convenience wrapper for `Object.assign`.\n *\n * @param {Object} target\n * @param {...Object} others\n *\n * @return {Object} the target\n */\nfunction assign(target, ...others) {\n  return Object.assign(target, ...others);\n}\n\n/**\n * Sets a nested property of a given object to the specified value.\n *\n * This mutates the object and returns it.\n *\n * @template T\n *\n * @param {T} target The target of the set operation.\n * @param {(string|number)[]} path The path to the nested value.\n * @param {any} value The value to set.\n *\n * @return {T}\n */\nfunction set(target, path, value) {\n\n  let currentTarget = target;\n\n  forEach(path, function(key, idx) {\n\n    if (typeof key !== 'number' && typeof key !== 'string') {\n      throw new Error('illegal key type: ' + typeof key + '. Key should be of type number or string.');\n    }\n\n    if (key === 'constructor') {\n      throw new Error('illegal key: constructor');\n    }\n\n    if (key === '__proto__') {\n      throw new Error('illegal key: __proto__');\n    }\n\n    let nextKey = path[idx + 1];\n    let nextTarget = currentTarget[key];\n\n    if (isDefined(nextKey) && isNil(nextTarget)) {\n      nextTarget = currentTarget[key] = isNaN(+nextKey) ? {} : [];\n    }\n\n    if (isUndefined(nextKey)) {\n      if (isUndefined(value)) {\n        delete currentTarget[key];\n      } else {\n        currentTarget[key] = value;\n      }\n    } else {\n      currentTarget = nextTarget;\n    }\n  });\n\n  return target;\n}\n\n\n/**\n * Gets a nested property of a given object.\n *\n * @param {Object} target The target of the get operation.\n * @param {(string|number)[]} path The path to the nested value.\n * @param {any} [defaultValue] The value to return if no value exists.\n *\n * @return {any}\n */\nfunction get(target, path, defaultValue) {\n\n  let currentTarget = target;\n\n  forEach(path, function(key) {\n\n    // accessing nil property yields <undefined>\n    if (isNil(currentTarget)) {\n      currentTarget = undefined;\n\n      return false;\n    }\n\n    currentTarget = currentTarget[key];\n  });\n\n  return isUndefined(currentTarget) ? defaultValue : currentTarget;\n}\n\n/**\n * Pick properties from the given target.\n *\n * @template T\n * @template {any[]} V\n *\n * @param {T} target\n * @param {V} properties\n *\n * @return Pick<T, V>\n */\nfunction pick(target, properties) {\n\n  let result = {};\n\n  let obj = Object(target);\n\n  forEach(properties, function(prop) {\n\n    if (prop in obj) {\n      result[prop] = target[prop];\n    }\n  });\n\n  return result;\n}\n\n/**\n * Pick all target properties, excluding the given ones.\n *\n * @template T\n * @template {any[]} V\n *\n * @param {T} target\n * @param {V} properties\n *\n * @return {Omit<T, V>} target\n */\nfunction omit(target, properties) {\n\n  let result = {};\n\n  let obj = Object(target);\n\n  forEach(obj, function(prop, key) {\n\n    if (properties.indexOf(key) === -1) {\n      result[key] = prop;\n    }\n  });\n\n  return result;\n}\n\n/**\n * Recursively merge `...sources` into given target.\n *\n * Does support merging objects; does not support merging arrays.\n *\n * @param {Object} target\n * @param {...Object} sources\n *\n * @return {Object} the target\n */\nfunction merge(target, ...sources) {\n\n  if (!sources.length) {\n    return target;\n  }\n\n  forEach(sources, function(source) {\n\n    // skip non-obj sources, i.e. null\n    if (!source || !isObject(source)) {\n      return;\n    }\n\n    forEach(source, function(sourceVal, key) {\n\n      if (key === '__proto__') {\n        return;\n      }\n\n      let targetVal = target[key];\n\n      if (isObject(sourceVal)) {\n\n        if (!isObject(targetVal)) {\n\n          // override target[key] with object\n          targetVal = {};\n        }\n\n        target[key] = merge(targetVal, sourceVal);\n      } else {\n        target[key] = sourceVal;\n      }\n\n    });\n  });\n\n  return target;\n}\n\nexport { assign, bind, debounce, ensureArray, every, filter, find, findIndex, flatten, forEach, get, groupBy, has, isArray, isDefined, isFunction, isNil, isNumber, isObject, isString, isUndefined, keys, map, matchPattern, merge, omit, pick, reduce, set, size, some, sortBy, throttle, unionBy, uniqueBy, values, without };\n", "/**\n * Moddle base element.\n */\nexport default function Base() { }\n\nBase.prototype.get = function(name) {\n  return this.$model.properties.get(this, name);\n};\n\nBase.prototype.set = function(name, value) {\n  this.$model.properties.set(this, name, value);\n};", "import {\n  forEach,\n  bind\n} from 'min-dash';\n\nimport Base from './base.js';\n\n/**\n * A model element factory.\n *\n * @param {Moddle} model\n * @param {Properties} properties\n */\nexport default function Factory(model, properties) {\n  this.model = model;\n  this.properties = properties;\n}\n\n\nFactory.prototype.createType = function(descriptor) {\n\n  var model = this.model;\n\n  var props = this.properties,\n      prototype = Object.create(Base.prototype);\n\n  // initialize default values\n  forEach(descriptor.properties, function(p) {\n    if (!p.isMany && p.default !== undefined) {\n      prototype[p.name] = p.default;\n    }\n  });\n\n  props.defineModel(prototype, model);\n  props.defineDescriptor(prototype, descriptor);\n\n  var name = descriptor.ns.name;\n\n  /**\n   * The new type constructor\n   */\n  function ModdleElement(attrs) {\n    props.define(this, '$type', { value: name, enumerable: true });\n    props.define(this, '$attrs', { value: {} });\n    props.define(this, '$parent', { writable: true });\n\n    forEach(attrs, bind(function(val, key) {\n      this.set(key, val);\n    }, this));\n  }\n\n  ModdleElement.prototype = prototype;\n\n  ModdleElement.hasType = prototype.$instanceOf = this.model.hasType;\n\n  // static links\n  props.defineModel(ModdleElement, model);\n  props.defineDescriptor(ModdleElement, descriptor);\n\n  return ModdleElement;\n};", "/**\n * Built-in moddle types\n */\nvar BUILTINS = {\n  String: true,\n  Boolean: true,\n  Integer: true,\n  Real: true,\n  Element: true\n};\n\n/**\n * Converters for built in types from string representations\n */\nvar TYPE_CONVERTERS = {\n  String: function(s) { return s; },\n  Boolean: function(s) { return s === 'true'; },\n  Integer: function(s) { return parseInt(s, 10); },\n  Real: function(s) { return parseFloat(s); }\n};\n\n/**\n * Convert a type to its real representation\n */\nexport function coerceType(type, value) {\n\n  var converter = TYPE_CONVERTERS[type];\n\n  if (converter) {\n    return converter(value);\n  } else {\n    return value;\n  }\n}\n\n/**\n * Return whether the given type is built-in\n */\nexport function isBuiltIn(type) {\n  return !!BUILTINS[type];\n}\n\n/**\n * Return whether the given type is simple\n */\nexport function isSimple(type) {\n  return !!TYPE_CONVERTERS[type];\n}", "/**\n * Parses a namespaced attribute name of the form (ns:)localName to an object,\n * given a default prefix to assume in case no explicit namespace is given.\n *\n * @param {String} name\n * @param {String} [defaultPrefix] the default prefix to take, if none is present.\n *\n * @return {Object} the parsed name\n */\nexport function parseName(name, defaultPrefix) {\n  var parts = name.split(/:/),\n      localName, prefix;\n\n  // no prefix (i.e. only local name)\n  if (parts.length === 1) {\n    localName = name;\n    prefix = defaultPrefix;\n  }\n\n  // prefix + local name\n  else if (parts.length === 2) {\n    localName = parts[1];\n    prefix = parts[0];\n  }\n\n  else {\n    throw new Error('expected <prefix:localName> or <localName>, got ' + name);\n  }\n\n  name = (prefix ? prefix + ':' : '') + localName;\n\n  return {\n    name: name,\n    prefix: prefix,\n    localName: localName\n  };\n}", "import {\n  pick,\n  assign,\n  forEach,\n  bind\n} from 'min-dash';\n\nimport {\n  parseName as parseNameNs\n} from './ns.js';\n\n\n/**\n * A utility to build element descriptors.\n */\nexport default function DescriptorBuilder(nameNs) {\n  this.ns = nameNs;\n  this.name = nameNs.name;\n  this.allTypes = [];\n  this.allTypesByName = {};\n  this.properties = [];\n  this.propertiesByName = {};\n}\n\n\nDescriptorBuilder.prototype.build = function() {\n  return pick(this, [\n    'ns',\n    'name',\n    'allTypes',\n    'allTypesByName',\n    'properties',\n    'propertiesByName',\n    'bodyProperty',\n    'idProperty'\n  ]);\n};\n\n/**\n * Add property at given index.\n *\n * @param {Object} p\n * @param {Number} [idx]\n * @param {Boolean} [validate=true]\n */\nDescriptorBuilder.prototype.addProperty = function(p, idx, validate) {\n\n  if (typeof idx === 'boolean') {\n    validate = idx;\n    idx = undefined;\n  }\n\n  this.addNamedProperty(p, validate !== false);\n\n  var properties = this.properties;\n\n  if (idx !== undefined) {\n    properties.splice(idx, 0, p);\n  } else {\n    properties.push(p);\n  }\n};\n\n\nDescriptorBuilder.prototype.replaceProperty = function(oldProperty, newProperty, replace) {\n  var oldNameNs = oldProperty.ns;\n\n  var props = this.properties,\n      propertiesByName = this.propertiesByName,\n      rename = oldProperty.name !== newProperty.name;\n\n  if (oldProperty.isId) {\n    if (!newProperty.isId) {\n      throw new Error(\n        'property <' + newProperty.ns.name + '> must be id property ' +\n        'to refine <' + oldProperty.ns.name + '>');\n    }\n\n    this.setIdProperty(newProperty, false);\n  }\n\n  if (oldProperty.isBody) {\n\n    if (!newProperty.isBody) {\n      throw new Error(\n        'property <' + newProperty.ns.name + '> must be body property ' +\n        'to refine <' + oldProperty.ns.name + '>');\n    }\n\n    // TODO: Check compatibility\n    this.setBodyProperty(newProperty, false);\n  }\n\n  // validate existence and get location of old property\n  var idx = props.indexOf(oldProperty);\n  if (idx === -1) {\n    throw new Error('property <' + oldNameNs.name + '> not found in property list');\n  }\n\n  // remove old property\n  props.splice(idx, 1);\n\n  // replacing the named property is intentional\n  //\n  //  * validate only if this is a \"rename\" operation\n  //  * add at specific index unless we \"replace\"\n  //\n  this.addProperty(newProperty, replace ? undefined : idx, rename);\n\n  // make new property available under old name\n  propertiesByName[oldNameNs.name] = propertiesByName[oldNameNs.localName] = newProperty;\n};\n\n\nDescriptorBuilder.prototype.redefineProperty = function(p, targetPropertyName, replace) {\n\n  var nsPrefix = p.ns.prefix;\n  var parts = targetPropertyName.split('#');\n\n  var name = parseNameNs(parts[0], nsPrefix);\n  var attrName = parseNameNs(parts[1], name.prefix).name;\n\n  var redefinedProperty = this.propertiesByName[attrName];\n  if (!redefinedProperty) {\n    throw new Error('refined property <' + attrName + '> not found');\n  } else {\n    this.replaceProperty(redefinedProperty, p, replace);\n  }\n\n  delete p.redefines;\n};\n\nDescriptorBuilder.prototype.addNamedProperty = function(p, validate) {\n  var ns = p.ns,\n      propsByName = this.propertiesByName;\n\n  if (validate) {\n    this.assertNotDefined(p, ns.name);\n    this.assertNotDefined(p, ns.localName);\n  }\n\n  propsByName[ns.name] = propsByName[ns.localName] = p;\n};\n\nDescriptorBuilder.prototype.removeNamedProperty = function(p) {\n  var ns = p.ns,\n      propsByName = this.propertiesByName;\n\n  delete propsByName[ns.name];\n  delete propsByName[ns.localName];\n};\n\nDescriptorBuilder.prototype.setBodyProperty = function(p, validate) {\n\n  if (validate && this.bodyProperty) {\n    throw new Error(\n      'body property defined multiple times ' +\n      '(<' + this.bodyProperty.ns.name + '>, <' + p.ns.name + '>)');\n  }\n\n  this.bodyProperty = p;\n};\n\nDescriptorBuilder.prototype.setIdProperty = function(p, validate) {\n\n  if (validate && this.idProperty) {\n    throw new Error(\n      'id property defined multiple times ' +\n      '(<' + this.idProperty.ns.name + '>, <' + p.ns.name + '>)');\n  }\n\n  this.idProperty = p;\n};\n\nDescriptorBuilder.prototype.assertNotTrait = function(typeDescriptor) {\n\n  const _extends = typeDescriptor.extends || [];\n\n  if (_extends.length) {\n    throw new Error(\n      `cannot create <${ typeDescriptor.name }> extending <${ typeDescriptor.extends }>`\n    );\n  }\n};\n\nDescriptorBuilder.prototype.assertNotDefined = function(p, name) {\n  var propertyName = p.name,\n      definedProperty = this.propertiesByName[propertyName];\n\n  if (definedProperty) {\n    throw new Error(\n      'property <' + propertyName + '> already defined; ' +\n      'override of <' + definedProperty.definedBy.ns.name + '#' + definedProperty.ns.name + '> by ' +\n      '<' + p.definedBy.ns.name + '#' + p.ns.name + '> not allowed without redefines');\n  }\n};\n\nDescriptorBuilder.prototype.hasProperty = function(name) {\n  return this.propertiesByName[name];\n};\n\nDescriptorBuilder.prototype.addTrait = function(t, inherited) {\n\n  if (inherited) {\n    this.assertNotTrait(t);\n  }\n\n  var typesByName = this.allTypesByName,\n      types = this.allTypes;\n\n  var typeName = t.name;\n\n  if (typeName in typesByName) {\n    return;\n  }\n\n  forEach(t.properties, bind(function(p) {\n\n    // clone property to allow extensions\n    p = assign({}, p, {\n      name: p.ns.localName,\n      inherited: inherited\n    });\n\n    Object.defineProperty(p, 'definedBy', {\n      value: t\n    });\n\n    var replaces = p.replaces,\n        redefines = p.redefines;\n\n    // add replace/redefine support\n    if (replaces || redefines) {\n      this.redefineProperty(p, replaces || redefines, replaces);\n    } else {\n      if (p.isBody) {\n        this.setBodyProperty(p);\n      }\n      if (p.isId) {\n        this.setIdProperty(p);\n      }\n      this.addProperty(p);\n    }\n  }, this));\n\n  types.push(t);\n  typesByName[typeName] = t;\n};", "import {\n  assign,\n  forEach,\n  bind\n} from 'min-dash';\n\nimport {\n  isBuiltIn as isBuiltInType\n} from './types.js';\n\nimport DescriptorBuilder from './descriptor-builder.js';\n\nimport {\n  parseName as parseNameNs\n} from './ns.js';\n\n\n/**\n * A registry of Moddle packages.\n *\n * @param {Array<Package>} packages\n * @param {Properties} properties\n */\nexport default function Registry(packages, properties) {\n  this.packageMap = {};\n  this.typeMap = {};\n\n  this.packages = [];\n\n  this.properties = properties;\n\n  forEach(packages, bind(this.registerPackage, this));\n}\n\n\nRegistry.prototype.getPackage = function(uriOrPrefix) {\n  return this.packageMap[uriOrPrefix];\n};\n\nRegistry.prototype.getPackages = function() {\n  return this.packages;\n};\n\n\nRegistry.prototype.registerPackage = function(pkg) {\n\n  // copy package\n  pkg = assign({}, pkg);\n\n  var pkgMap = this.packageMap;\n\n  ensureAvailable(pkgMap, pkg, 'prefix');\n  ensureAvailable(pkgMap, pkg, 'uri');\n\n  // register types\n  forEach(pkg.types, bind(function(descriptor) {\n    this.registerType(descriptor, pkg);\n  }, this));\n\n  pkgMap[pkg.uri] = pkgMap[pkg.prefix] = pkg;\n  this.packages.push(pkg);\n};\n\n\n/**\n * Register a type from a specific package with us\n */\nRegistry.prototype.registerType = function(type, pkg) {\n\n  type = assign({}, type, {\n    superClass: (type.superClass || []).slice(),\n    extends: (type.extends || []).slice(),\n    properties: (type.properties || []).slice(),\n    meta: assign(({}, type.meta || {}))\n  });\n\n  var ns = parseNameNs(type.name, pkg.prefix),\n      name = ns.name,\n      propertiesByName = {};\n\n  // parse properties\n  forEach(type.properties, bind(function(p) {\n\n    // namespace property names\n    var propertyNs = parseNameNs(p.name, ns.prefix),\n        propertyName = propertyNs.name;\n\n    // namespace property types\n    if (!isBuiltInType(p.type)) {\n      p.type = parseNameNs(p.type, propertyNs.prefix).name;\n    }\n\n    assign(p, {\n      ns: propertyNs,\n      name: propertyName\n    });\n\n    propertiesByName[propertyName] = p;\n  }, this));\n\n  // update ns + name\n  assign(type, {\n    ns: ns,\n    name: name,\n    propertiesByName: propertiesByName\n  });\n\n  forEach(type.extends, bind(function(extendsName) {\n    var extendsNameNs = parseNameNs(extendsName, ns.prefix);\n\n    var extended = this.typeMap[extendsNameNs.name];\n\n    extended.traits = extended.traits || [];\n    extended.traits.push(name);\n  }, this));\n\n  // link to package\n  this.definePackage(type, pkg);\n\n  // register\n  this.typeMap[name] = type;\n};\n\n\n/**\n * Traverse the type hierarchy from bottom to top,\n * calling iterator with (type, inherited) for all elements in\n * the inheritance chain.\n *\n * @param {Object} nsName\n * @param {Function} iterator\n * @param {Boolean} [trait=false]\n */\nRegistry.prototype.mapTypes = function(nsName, iterator, trait) {\n\n  var type = isBuiltInType(nsName.name) ? { name: nsName.name } : this.typeMap[nsName.name];\n\n  var self = this;\n\n  /**\n   * Traverse the selected super type or trait\n   *\n   * @param {String} cls\n   * @param {Boolean} [trait=false]\n   */\n  function traverse(cls, trait) {\n    var parentNs = parseNameNs(cls, isBuiltInType(cls) ? '' : nsName.prefix);\n    self.mapTypes(parentNs, iterator, trait);\n  }\n\n  /**\n   * Traverse the selected trait.\n   *\n   * @param {String} cls\n   */\n  function traverseTrait(cls) {\n    return traverse(cls, true);\n  }\n\n  /**\n   * Traverse the selected super type\n   *\n   * @param {String} cls\n   */\n  function traverseSuper(cls) {\n    return traverse(cls, false);\n  }\n\n  if (!type) {\n    throw new Error('unknown type <' + nsName.name + '>');\n  }\n\n  forEach(type.superClass, trait ? traverseTrait : traverseSuper);\n\n  // call iterator with (type, inherited=!trait)\n  iterator(type, !trait);\n\n  forEach(type.traits, traverseTrait);\n};\n\n\n/**\n * Returns the effective descriptor for a type.\n *\n * @param  {String} type the namespaced name (ns:localName) of the type\n *\n * @return {Descriptor} the resulting effective descriptor\n */\nRegistry.prototype.getEffectiveDescriptor = function(name) {\n\n  var nsName = parseNameNs(name);\n\n  var builder = new DescriptorBuilder(nsName);\n\n  this.mapTypes(nsName, function(type, inherited) {\n    builder.addTrait(type, inherited);\n  });\n\n  var descriptor = builder.build();\n\n  // define package link\n  this.definePackage(descriptor, descriptor.allTypes[descriptor.allTypes.length - 1].$pkg);\n\n  return descriptor;\n};\n\n\nRegistry.prototype.definePackage = function(target, pkg) {\n  this.properties.define(target, '$pkg', { value: pkg });\n};\n\n\n\n// helpers ////////////////////////////\n\nfunction ensureAvailable(packageMap, pkg, identifierKey) {\n\n  var value = pkg[identifierKey];\n\n  if (value in packageMap) {\n    throw new Error('package with ' + identifierKey + ' <' + value + '> already defined');\n  }\n}\n", "import {\n  assign,\n  isString\n} from 'min-dash';\n\n/**\n * A utility that gets and sets properties of model elements.\n *\n * @param {Model} model\n */\nexport default function Properties(model) {\n  this.model = model;\n}\n\n\n/**\n * Sets a named property on the target element.\n * If the value is undefined, the property gets deleted.\n *\n * @param {Object} target\n * @param {String} name\n * @param {Object} value\n */\nProperties.prototype.set = function(target, name, value) {\n\n  if (!isString(name) || !name.length) {\n    throw new TypeError('property name must be a non-empty string');\n  }\n\n  var property = this.getProperty(target, name);\n\n  var propertyName = property && property.name;\n\n  if (isUndefined(value)) {\n\n    // unset the property, if the specified value is undefined;\n    // delete from $attrs (for extensions) or the target itself\n    if (property) {\n      delete target[propertyName];\n    } else {\n      delete target.$attrs[stripGlobal(name)];\n    }\n  } else {\n\n    // set the property, defining well defined properties on the fly\n    // or simply updating them in target.$attrs (for extensions)\n    if (property) {\n      if (propertyName in target) {\n        target[propertyName] = value;\n      } else {\n        defineProperty(target, property, value);\n      }\n    } else {\n      target.$attrs[stripGlobal(name)] = value;\n    }\n  }\n};\n\n/**\n * Returns the named property of the given element\n *\n * @param  {Object} target\n * @param  {String} name\n *\n * @return {Object}\n */\nProperties.prototype.get = function(target, name) {\n\n  var property = this.getProperty(target, name);\n\n  if (!property) {\n    return target.$attrs[stripGlobal(name)];\n  }\n\n  var propertyName = property.name;\n\n  // check if access to collection property and lazily initialize it\n  if (!target[propertyName] && property.isMany) {\n    defineProperty(target, property, []);\n  }\n\n  return target[propertyName];\n};\n\n\n/**\n * Define a property on the target element\n *\n * @param  {Object} target\n * @param  {String} name\n * @param  {Object} options\n */\nProperties.prototype.define = function(target, name, options) {\n\n  if (!options.writable) {\n\n    var value = options.value;\n\n    // use getters for read-only variables to support ES6 proxies\n    // cf. https://github.com/bpmn-io/internal-docs/issues/386\n    options = assign({}, options, {\n      get: function() { return value; }\n    });\n\n    delete options.value;\n  }\n\n  Object.defineProperty(target, name, options);\n};\n\n\n/**\n * Define the descriptor for an element\n */\nProperties.prototype.defineDescriptor = function(target, descriptor) {\n  this.define(target, '$descriptor', { value: descriptor });\n};\n\n/**\n * Define the model for an element\n */\nProperties.prototype.defineModel = function(target, model) {\n  this.define(target, '$model', { value: model });\n};\n\n/**\n * Return property with the given name on the element.\n *\n * @param {any} target\n * @param {string} name\n *\n * @return {object | null} property\n */\nProperties.prototype.getProperty = function(target, name) {\n\n  var model = this.model;\n\n  var property = model.getPropertyDescriptor(target, name);\n\n  if (property) {\n    return property;\n  }\n\n  if (name.includes(':')) {\n    return null;\n  }\n\n  const strict = model.config.strict;\n\n  if (typeof strict !== 'undefined') {\n    const error = new TypeError(`unknown property <${ name }> on <${ target.$type }>`);\n\n    if (strict) {\n      throw error;\n    } else {\n\n      // eslint-disable-next-line no-undef\n      typeof console !== 'undefined' && console.warn(error);\n    }\n  }\n\n  return null;\n};\n\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\nfunction defineProperty(target, property, value) {\n  Object.defineProperty(target, property.name, {\n    enumerable: !property.isReference,\n    writable: true,\n    value: value,\n    configurable: true\n  });\n}\n\nfunction stripGlobal(name) {\n  return name.replace(/^:/, '');\n}", "import {\n  isString,\n  isObject,\n  forEach,\n  set\n} from 'min-dash';\n\nimport Factory from './factory.js';\nimport Registry from './registry.js';\nimport Properties from './properties.js';\n\nimport {\n  parseName as parseNameNs\n} from './ns.js';\n\n\n// Moddle implementation /////////////////////////////////////////////////\n\n/**\n * @class Moddle\n *\n * A model that can be used to create elements of a specific type.\n *\n * @example\n *\n * var Moddle = require('moddle');\n *\n * var pkg = {\n *   name: 'mypackage',\n *   prefix: 'my',\n *   types: [\n *     { name: 'Root' }\n *   ]\n * };\n *\n * var moddle = new Moddle([pkg]);\n *\n * @param {Array<Package>} packages the packages to contain\n *\n * @param { { strict?: boolean } } [config] moddle configuration\n */\nexport default function Moddle(packages, config = {}) {\n\n  this.properties = new Properties(this);\n\n  this.factory = new Factory(this, this.properties);\n  this.registry = new Registry(packages, this.properties);\n\n  this.typeCache = {};\n\n  this.config = config;\n}\n\n\n/**\n * Create an instance of the specified type.\n *\n * @method Moddle#create\n *\n * @example\n *\n * var foo = moddle.create('my:Foo');\n * var bar = moddle.create('my:Bar', { id: 'BAR_1' });\n *\n * @param  {String|Object} descriptor the type descriptor or name know to the model\n * @param  {Object} attrs   a number of attributes to initialize the model instance with\n * @return {Object}         model instance\n */\nModdle.prototype.create = function(descriptor, attrs) {\n  var Type = this.getType(descriptor);\n\n  if (!Type) {\n    throw new Error('unknown type <' + descriptor + '>');\n  }\n\n  return new Type(attrs);\n};\n\n\n/**\n * Returns the type representing a given descriptor\n *\n * @method Moddle#getType\n *\n * @example\n *\n * var Foo = moddle.getType('my:Foo');\n * var foo = new Foo({ 'id' : 'FOO_1' });\n *\n * @param  {String|Object} descriptor the type descriptor or name know to the model\n * @return {Object}         the type representing the descriptor\n */\nModdle.prototype.getType = function(descriptor) {\n\n  var cache = this.typeCache;\n\n  var name = isString(descriptor) ? descriptor : descriptor.ns.name;\n\n  var type = cache[name];\n\n  if (!type) {\n    descriptor = this.registry.getEffectiveDescriptor(name);\n    type = cache[name] = this.factory.createType(descriptor);\n  }\n\n  return type;\n};\n\n\n/**\n * Creates an any-element type to be used within model instances.\n *\n * This can be used to create custom elements that lie outside the meta-model.\n * The created element contains all the meta-data required to serialize it\n * as part of meta-model elements.\n *\n * @method Moddle#createAny\n *\n * @example\n *\n * var foo = moddle.createAny('vendor:Foo', 'http://vendor', {\n *   value: 'bar'\n * });\n *\n * var container = moddle.create('my:Container', 'http://my', {\n *   any: [ foo ]\n * });\n *\n * // go ahead and serialize the stuff\n *\n *\n * @param  {String} name  the name of the element\n * @param  {String} nsUri the namespace uri of the element\n * @param  {Object} [properties] a map of properties to initialize the instance with\n * @return {Object} the any type instance\n */\nModdle.prototype.createAny = function(name, nsUri, properties) {\n\n  var nameNs = parseNameNs(name);\n\n  var element = {\n    $type: name,\n    $instanceOf: function(type) {\n      return type === this.$type;\n    },\n    get: function(key) {\n      return this[key];\n    },\n    set: function(key, value) {\n      set(this, [ key ], value);\n    }\n  };\n\n  var descriptor = {\n    name: name,\n    isGeneric: true,\n    ns: {\n      prefix: nameNs.prefix,\n      localName: nameNs.localName,\n      uri: nsUri\n    }\n  };\n\n  this.properties.defineDescriptor(element, descriptor);\n  this.properties.defineModel(element, this);\n  this.properties.define(element, 'get', { enumerable: false, writable: true });\n  this.properties.define(element, 'set', { enumerable: false, writable: true });\n  this.properties.define(element, '$parent', { enumerable: false, writable: true });\n  this.properties.define(element, '$instanceOf', { enumerable: false, writable: true });\n\n  forEach(properties, function(a, key) {\n    if (isObject(a) && a.value !== undefined) {\n      element[a.name] = a.value;\n    } else {\n      element[key] = a;\n    }\n  });\n\n  return element;\n};\n\n/**\n * Returns a registered package by uri or prefix\n *\n * @return {Object} the package\n */\nModdle.prototype.getPackage = function(uriOrPrefix) {\n  return this.registry.getPackage(uriOrPrefix);\n};\n\n/**\n * Returns a snapshot of all known packages\n *\n * @return {Object} the package\n */\nModdle.prototype.getPackages = function() {\n  return this.registry.getPackages();\n};\n\n/**\n * Returns the descriptor for an element\n */\nModdle.prototype.getElementDescriptor = function(element) {\n  return element.$descriptor;\n};\n\n/**\n * Returns true if the given descriptor or instance\n * represents the given type.\n *\n * May be applied to this, if element is omitted.\n */\nModdle.prototype.hasType = function(element, type) {\n  if (type === undefined) {\n    type = element;\n    element = this;\n  }\n\n  var descriptor = element.$model.getElementDescriptor(element);\n\n  return (type in descriptor.allTypesByName);\n};\n\n/**\n * Returns the descriptor of an elements named property\n */\nModdle.prototype.getPropertyDescriptor = function(element, property) {\n  return this.getElementDescriptor(element).propertiesByName[property];\n};\n\n/**\n * Returns a mapped type's descriptor\n */\nModdle.prototype.getTypeDescriptor = function(type) {\n  return this.registry.typeMap[type];\n};", "var fromCharCode = String.fromCharCode;\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar ENTITY_PATTERN = /&#(\\d+);|&#x([0-9a-f]+);|&(\\w+);/ig;\n\nvar ENTITY_MAPPING = {\n  'amp': '&',\n  'apos': '\\'',\n  'gt': '>',\n  'lt': '<',\n  'quot': '\"'\n};\n\n// map UPPERCASE variants of supported special chars\nObject.keys(ENTITY_MAPPING).forEach(function(k) {\n  ENTITY_MAPPING[k.toUpperCase()] = ENTITY_MAPPING[k];\n});\n\n\nfunction replaceEntities(_, d, x, z) {\n\n  // reserved names, i.e. &nbsp;\n  if (z) {\n    if (hasOwnProperty.call(ENTITY_MAPPING, z)) {\n      return ENTITY_MAPPING[z];\n    } else {\n\n      // fall back to original value\n      return '&' + z + ';';\n    }\n  }\n\n  // decimal encoded char\n  if (d) {\n    return fromCharCode(d);\n  }\n\n  // hex encoded char\n  return fromCharCode(parseInt(x, 16));\n}\n\n\n/**\n * A basic entity decoder that can decode a minimal\n * sub-set of reserved names (&amp;) as well as\n * hex (&#xaaf;) and decimal (&#1231;) encoded characters.\n *\n * @param {string} s\n *\n * @return {string} decoded string\n */\nexport default function decodeEntities(s) {\n  if (s.length > 3 && s.indexOf('&') !== -1) {\n    return s.replace(ENTITY_PATTERN, replaceEntities);\n  }\n\n  return s;\n}", "import decodeEntities from './decode.js';\n\nvar NON_WHITESPACE_OUTSIDE_ROOT_NODE = 'non-whitespace outside of root node';\n\nfunction error(msg) {\n  return new Error(msg);\n}\n\nfunction missingNamespaceForPrefix(prefix) {\n  return 'missing namespace for prefix <' + prefix + '>';\n}\n\nfunction getter(getFn) {\n  return {\n    'get': getFn,\n    'enumerable': true\n  };\n}\n\nfunction cloneNsMatrix(nsMatrix) {\n  var clone = {}, key;\n  for (key in nsMatrix) {\n    clone[key] = nsMatrix[key];\n  }\n  return clone;\n}\n\nfunction uriPrefix(prefix) {\n  return prefix + '$uri';\n}\n\nfunction buildNsMatrix(nsUriToPrefix) {\n  var nsMatrix = {},\n      uri,\n      prefix;\n\n  for (uri in nsUriToPrefix) {\n    prefix = nsUriToPrefix[uri];\n    nsMatrix[prefix] = prefix;\n    nsMatrix[uriPrefix(prefix)] = uri;\n  }\n\n  return nsMatrix;\n}\n\nfunction noopGetContext() {\n  return { line: 0, column: 0 };\n}\n\nfunction throwFunc(err) {\n  throw err;\n}\n\n/**\n * Creates a new parser with the given options.\n *\n * @constructor\n *\n * @param  {!Object<string, ?>=} options\n */\nexport default function Parser(options) {\n\n  if (!this) {\n    return new Parser(options);\n  }\n\n  var proxy = options && options['proxy'];\n\n  var onText,\n      onOpenTag,\n      onCloseTag,\n      onCDATA,\n      onError = throwFunc,\n      onWarning,\n      onComment,\n      onQuestion,\n      onAttention;\n\n  var getContext = noopGetContext;\n\n  /**\n   * Do we need to parse the current elements attributes for namespaces?\n   *\n   * @type {boolean}\n   */\n  var maybeNS = false;\n\n  /**\n   * Do we process namespaces at all?\n   *\n   * @type {boolean}\n   */\n  var isNamespace = false;\n\n  /**\n   * The caught error returned on parse end\n   *\n   * @type {Error}\n   */\n  var returnError = null;\n\n  /**\n   * Should we stop parsing?\n   *\n   * @type {boolean}\n   */\n  var parseStop = false;\n\n  /**\n   * A map of { uri: prefix } used by the parser.\n   *\n   * This map will ensure we can normalize prefixes during processing;\n   * for each uri, only one prefix will be exposed to the handlers.\n   *\n   * @type {!Object<string, string>}}\n   */\n  var nsUriToPrefix;\n\n  /**\n   * Handle parse error.\n   *\n   * @param  {string|Error} err\n   */\n  function handleError(err) {\n    if (!(err instanceof Error)) {\n      err = error(err);\n    }\n\n    returnError = err;\n\n    onError(err, getContext);\n  }\n\n  /**\n   * Handle parse error.\n   *\n   * @param  {string|Error} err\n   */\n  function handleWarning(err) {\n\n    if (!onWarning) {\n      return;\n    }\n\n    if (!(err instanceof Error)) {\n      err = error(err);\n    }\n\n    onWarning(err, getContext);\n  }\n\n  /**\n   * Register parse listener.\n   *\n   * @param  {string}   name\n   * @param  {Function} cb\n   *\n   * @return {Parser}\n   */\n  this['on'] = function(name, cb) {\n\n    if (typeof cb !== 'function') {\n      throw error('required args <name, cb>');\n    }\n\n    switch (name) {\n    case 'openTag': onOpenTag = cb; break;\n    case 'text': onText = cb; break;\n    case 'closeTag': onCloseTag = cb; break;\n    case 'error': onError = cb; break;\n    case 'warn': onWarning = cb; break;\n    case 'cdata': onCDATA = cb; break;\n    case 'attention': onAttention = cb; break; // <!XXXXX zzzz=\"eeee\">\n    case 'question': onQuestion = cb; break; // <? ....  ?>\n    case 'comment': onComment = cb; break;\n    default:\n      throw error('unsupported event: ' + name);\n    }\n\n    return this;\n  };\n\n  /**\n   * Set the namespace to prefix mapping.\n   *\n   * @example\n   *\n   * parser.ns({\n   *   'http://foo': 'foo',\n   *   'http://bar': 'bar'\n   * });\n   *\n   * @param  {!Object<string, string>} nsMap\n   *\n   * @return {Parser}\n   */\n  this['ns'] = function(nsMap) {\n\n    if (typeof nsMap === 'undefined') {\n      nsMap = {};\n    }\n\n    if (typeof nsMap !== 'object') {\n      throw error('required args <nsMap={}>');\n    }\n\n    var _nsUriToPrefix = {}, k;\n\n    for (k in nsMap) {\n      _nsUriToPrefix[k] = nsMap[k];\n    }\n\n    isNamespace = true;\n    nsUriToPrefix = _nsUriToPrefix;\n\n    return this;\n  };\n\n  /**\n   * Parse xml string.\n   *\n   * @param  {string} xml\n   *\n   * @return {Error} returnError, if not thrown\n   */\n  this['parse'] = function(xml) {\n    if (typeof xml !== 'string') {\n      throw error('required args <xml=string>');\n    }\n\n    returnError = null;\n\n    parse(xml);\n\n    getContext = noopGetContext;\n    parseStop = false;\n\n    return returnError;\n  };\n\n  /**\n   * Stop parsing.\n   */\n  this['stop'] = function() {\n    parseStop = true;\n  };\n\n  /**\n   * Parse string, invoking configured listeners on element.\n   *\n   * @param  {string} xml\n   */\n  function parse(xml) {\n    var nsMatrixStack = isNamespace ? [] : null,\n        nsMatrix = isNamespace ? buildNsMatrix(nsUriToPrefix) : null,\n        _nsMatrix,\n        nodeStack = [],\n        anonymousNsCount = 0,\n        tagStart = false,\n        tagEnd = false,\n        i = 0, j = 0,\n        x, y, q, w, v,\n        xmlns,\n        elementName,\n        _elementName,\n        elementProxy\n        ;\n\n    var attrsString = '',\n        attrsStart = 0,\n        cachedAttrs // false = parsed with errors, null = needs parsing\n        ;\n\n    /**\n     * Parse attributes on demand and returns the parsed attributes.\n     *\n     * Return semantics: (1) `false` on attribute parse error,\n     * (2) object hash on extracted attrs.\n     *\n     * @return {boolean|Object}\n     */\n    function getAttrs() {\n      if (cachedAttrs !== null) {\n        return cachedAttrs;\n      }\n\n      var nsUri,\n          nsUriPrefix,\n          nsName,\n          defaultAlias = isNamespace && nsMatrix['xmlns'],\n          attrList = isNamespace && maybeNS ? [] : null,\n          i = attrsStart,\n          s = attrsString,\n          l = s.length,\n          hasNewMatrix,\n          newalias,\n          value,\n          alias,\n          name,\n          attrs = {},\n          seenAttrs = {},\n          skipAttr,\n          w,\n          j;\n\n      parseAttr:\n      for (; i < l; i++) {\n        skipAttr = false;\n        w = s.charCodeAt(i);\n\n        if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE={ \\f\\n\\r\\t\\v}\n          continue;\n        }\n\n        // wait for non whitespace character\n        if (w < 65 || w > 122 || (w > 90 && w < 97)) {\n          if (w !== 95 && w !== 58) { // char 95\"_\" 58\":\"\n            handleWarning('illegal first char attribute name');\n            skipAttr = true;\n          }\n        }\n\n        // parse attribute name\n        for (j = i + 1; j < l; j++) {\n          w = s.charCodeAt(j);\n\n          if (\n            w > 96 && w < 123 ||\n            w > 64 && w < 91 ||\n            w > 47 && w < 59 ||\n            w === 46 || // '.'\n            w === 45 || // '-'\n            w === 95 // '_'\n          ) {\n            continue;\n          }\n\n          // unexpected whitespace\n          if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE\n            handleWarning('missing attribute value');\n            i = j;\n\n            continue parseAttr;\n          }\n\n          // expected \"=\"\n          if (w === 61) { // \"=\" == 61\n            break;\n          }\n\n          handleWarning('illegal attribute name char');\n          skipAttr = true;\n        }\n\n        name = s.substring(i, j);\n\n        if (name === 'xmlns:xmlns') {\n          handleWarning('illegal declaration of xmlns');\n          skipAttr = true;\n        }\n\n        w = s.charCodeAt(j + 1);\n\n        if (w === 34) { // '\"'\n          j = s.indexOf('\"', i = j + 2);\n\n          if (j === -1) {\n            j = s.indexOf('\\'', i);\n\n            if (j !== -1) {\n              handleWarning('attribute value quote missmatch');\n              skipAttr = true;\n            }\n          }\n\n        } else if (w === 39) { // \"'\"\n          j = s.indexOf('\\'', i = j + 2);\n\n          if (j === -1) {\n            j = s.indexOf('\"', i);\n\n            if (j !== -1) {\n              handleWarning('attribute value quote missmatch');\n              skipAttr = true;\n            }\n          }\n\n        } else {\n          handleWarning('missing attribute value quotes');\n          skipAttr = true;\n\n          // skip to next space\n          for (j = j + 1; j < l; j++) {\n            w = s.charCodeAt(j + 1);\n\n            if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE\n              break;\n            }\n          }\n\n        }\n\n        if (j === -1) {\n          handleWarning('missing closing quotes');\n\n          j = l;\n          skipAttr = true;\n        }\n\n        if (!skipAttr) {\n          value = s.substring(i, j);\n        }\n\n        i = j;\n\n        // ensure SPACE follows attribute\n        // skip illegal content otherwise\n        // example a=\"b\"c\n        for (; j + 1 < l; j++) {\n          w = s.charCodeAt(j + 1);\n\n          if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE\n            break;\n          }\n\n          // FIRST ILLEGAL CHAR\n          if (i === j) {\n            handleWarning('illegal character after attribute end');\n            skipAttr = true;\n          }\n        }\n\n        // advance cursor to next attribute\n        i = j + 1;\n\n        if (skipAttr) {\n          continue parseAttr;\n        }\n\n        // check attribute re-declaration\n        if (name in seenAttrs) {\n          handleWarning('attribute <' + name + '> already defined');\n          continue;\n        }\n\n        seenAttrs[name] = true;\n\n        if (!isNamespace) {\n          attrs[name] = value;\n          continue;\n        }\n\n        // try to extract namespace information\n        if (maybeNS) {\n          newalias = (\n            name === 'xmlns'\n              ? 'xmlns'\n              : (name.charCodeAt(0) === 120 && name.substr(0, 6) === 'xmlns:')\n                ? name.substr(6)\n                : null\n          );\n\n          // handle xmlns(:alias) assignment\n          if (newalias !== null) {\n            nsUri = decodeEntities(value);\n            nsUriPrefix = uriPrefix(newalias);\n\n            alias = nsUriToPrefix[nsUri];\n\n            if (!alias) {\n\n              // no prefix defined or prefix collision\n              if (\n                (newalias === 'xmlns') ||\n                (nsUriPrefix in nsMatrix && nsMatrix[nsUriPrefix] !== nsUri)\n              ) {\n\n                // alocate free ns prefix\n                do {\n                  alias = 'ns' + (anonymousNsCount++);\n                } while (typeof nsMatrix[alias] !== 'undefined');\n              } else {\n                alias = newalias;\n              }\n\n              nsUriToPrefix[nsUri] = alias;\n            }\n\n            if (nsMatrix[newalias] !== alias) {\n              if (!hasNewMatrix) {\n                nsMatrix = cloneNsMatrix(nsMatrix);\n                hasNewMatrix = true;\n              }\n\n              nsMatrix[newalias] = alias;\n              if (newalias === 'xmlns') {\n                nsMatrix[uriPrefix(alias)] = nsUri;\n                defaultAlias = alias;\n              }\n\n              nsMatrix[nsUriPrefix] = nsUri;\n            }\n\n            // expose xmlns(:asd)=\"...\" in attributes\n            attrs[name] = value;\n            continue;\n          }\n\n          // collect attributes until all namespace\n          // declarations are processed\n          attrList.push(name, value);\n          continue;\n\n        } /** end if (maybeNs) */\n\n        // handle attributes on element without\n        // namespace declarations\n        w = name.indexOf(':');\n        if (w === -1) {\n          attrs[name] = value;\n          continue;\n        }\n\n        // normalize ns attribute name\n        if (!(nsName = nsMatrix[name.substring(0, w)])) {\n          handleWarning(missingNamespaceForPrefix(name.substring(0, w)));\n          continue;\n        }\n\n        name = defaultAlias === nsName\n          ? name.substr(w + 1)\n          : nsName + name.substr(w);\n\n        // end: normalize ns attribute name\n\n        attrs[name] = value;\n      }\n\n\n      // handle deferred, possibly namespaced attributes\n      if (maybeNS) {\n\n        // normalize captured attributes\n        for (i = 0, l = attrList.length; i < l; i++) {\n\n          name = attrList[i++];\n          value = attrList[i];\n\n          w = name.indexOf(':');\n\n          if (w !== -1) {\n\n            // normalize ns attribute name\n            if (!(nsName = nsMatrix[name.substring(0, w)])) {\n              handleWarning(missingNamespaceForPrefix(name.substring(0, w)));\n              continue;\n            }\n\n            name = defaultAlias === nsName\n              ? name.substr(w + 1)\n              : nsName + name.substr(w);\n\n            // end: normalize ns attribute name\n          }\n\n          attrs[name] = value;\n        }\n\n        // end: normalize captured attributes\n      }\n\n      return cachedAttrs = attrs;\n    }\n\n    /**\n     * Extract the parse context { line, column, part }\n     * from the current parser position.\n     *\n     * @return {Object} parse context\n     */\n    function getParseContext() {\n      var splitsRe = /(\\r\\n|\\r|\\n)/g;\n\n      var line = 0;\n      var column = 0;\n      var startOfLine = 0;\n      var endOfLine = j;\n      var match;\n      var data;\n\n      while (i >= startOfLine) {\n\n        match = splitsRe.exec(xml);\n\n        if (!match) {\n          break;\n        }\n\n        // end of line = (break idx + break chars)\n        endOfLine = match[0].length + match.index;\n\n        if (endOfLine > i) {\n          break;\n        }\n\n        // advance to next line\n        line += 1;\n\n        startOfLine = endOfLine;\n      }\n\n      // EOF errors\n      if (i == -1) {\n        column = endOfLine;\n        data = xml.substring(j);\n      } else\n\n      // start errors\n      if (j === 0) {\n        data = xml.substring(j, i);\n      }\n\n      // other errors\n      else {\n        column = i - startOfLine;\n        data = (j == -1 ? xml.substring(i) : xml.substring(i, j + 1));\n      }\n\n      return {\n        'data': data,\n        'line': line,\n        'column': column\n      };\n    }\n\n    getContext = getParseContext;\n\n\n    if (proxy) {\n      elementProxy = Object.create({}, {\n        'name': getter(function() {\n          return elementName;\n        }),\n        'originalName': getter(function() {\n          return _elementName;\n        }),\n        'attrs': getter(getAttrs),\n        'ns': getter(function() {\n          return nsMatrix;\n        })\n      });\n    }\n\n    // actual parse logic\n    while (j !== -1) {\n\n      if (xml.charCodeAt(j) === 60) { // \"<\"\n        i = j;\n      } else {\n        i = xml.indexOf('<', j);\n      }\n\n      // parse end\n      if (i === -1) {\n        if (nodeStack.length) {\n          return handleError('unexpected end of file');\n        }\n\n        if (j === 0) {\n          return handleError('missing start tag');\n        }\n\n        if (j < xml.length) {\n          if (xml.substring(j).trim()) {\n            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);\n          }\n        }\n\n        return;\n      }\n\n      // parse text\n      if (j !== i) {\n\n        if (nodeStack.length) {\n          if (onText) {\n            onText(xml.substring(j, i), decodeEntities, getContext);\n\n            if (parseStop) {\n              return;\n            }\n          }\n        } else {\n          if (xml.substring(j, i).trim()) {\n            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);\n\n            if (parseStop) {\n              return;\n            }\n          }\n        }\n      }\n\n      w = xml.charCodeAt(i + 1);\n\n      // parse comments + CDATA\n      if (w === 33) { // \"!\"\n        q = xml.charCodeAt(i + 2);\n\n        // CDATA section\n        if (q === 91 && xml.substr(i + 3, 6) === 'CDATA[') { // 91 == \"[\"\n          j = xml.indexOf(']]>', i);\n          if (j === -1) {\n            return handleError('unclosed cdata');\n          }\n\n          if (onCDATA) {\n            onCDATA(xml.substring(i + 9, j), getContext);\n            if (parseStop) {\n              return;\n            }\n          }\n\n          j += 3;\n          continue;\n        }\n\n        // comment\n        if (q === 45 && xml.charCodeAt(i + 3) === 45) { // 45 == \"-\"\n          j = xml.indexOf('-->', i);\n          if (j === -1) {\n            return handleError('unclosed comment');\n          }\n\n\n          if (onComment) {\n            onComment(xml.substring(i + 4, j), decodeEntities, getContext);\n            if (parseStop) {\n              return;\n            }\n          }\n\n          j += 3;\n          continue;\n        }\n      }\n\n      // parse question <? ... ?>\n      if (w === 63) { // \"?\"\n        j = xml.indexOf('?>', i);\n        if (j === -1) {\n          return handleError('unclosed question');\n        }\n\n        if (onQuestion) {\n          onQuestion(xml.substring(i, j + 2), getContext);\n          if (parseStop) {\n            return;\n          }\n        }\n\n        j += 2;\n        continue;\n      }\n\n      // find matching closing tag for attention or standard tags\n      // for that we must skip through attribute values\n      // (enclosed in single or double quotes)\n      for (x = i + 1; ; x++) {\n        v = xml.charCodeAt(x);\n        if (isNaN(v)) {\n          j = -1;\n          return handleError('unclosed tag');\n        }\n\n        // [10] AttValue ::= '\"' ([^<&\"] | Reference)* '\"' | \"'\" ([^<&'] | Reference)* \"'\"\n        // skips the quoted string\n        // (double quotes) does not appear in a literal enclosed by (double quotes)\n        // (single quote) does not appear in a literal enclosed by (single quote)\n        if (v === 34) { //  '\"'\n          q = xml.indexOf('\"', x + 1);\n          x = q !== -1 ? q : x;\n        } else if (v === 39) { // \"'\"\n          q = xml.indexOf(\"'\", x + 1);\n          x = q !== -1 ? q : x;\n        } else if (v === 62) { // '>'\n          j = x;\n          break;\n        }\n      }\n\n\n      // parse attention <! ...>\n      // previously comment and CDATA have already been parsed\n      if (w === 33) { // \"!\"\n\n        if (onAttention) {\n          onAttention(xml.substring(i, j + 1), decodeEntities, getContext);\n          if (parseStop) {\n            return;\n          }\n        }\n\n        j += 1;\n        continue;\n      }\n\n      // don't process attributes;\n      // there are none\n      cachedAttrs = {};\n\n      // if (xml.charCodeAt(i+1) === 47) { // </...\n      if (w === 47) { // </...\n        tagStart = false;\n        tagEnd = true;\n\n        if (!nodeStack.length) {\n          return handleError('missing open tag');\n        }\n\n        // verify open <-> close tag match\n        x = elementName = nodeStack.pop();\n        q = i + 2 + x.length;\n\n        if (xml.substring(i + 2, q) !== x) {\n          return handleError('closing tag mismatch');\n        }\n\n        // verify chars in close tag\n        for (; q < j; q++) {\n          w = xml.charCodeAt(q);\n\n          if (w === 32 || (w > 8 && w < 14)) { // \\f\\n\\r\\t\\v space\n            continue;\n          }\n\n          return handleError('close tag');\n        }\n\n      } else {\n        if (xml.charCodeAt(j - 1) === 47) { // .../>\n          x = elementName = xml.substring(i + 1, j - 1);\n\n          tagStart = true;\n          tagEnd = true;\n\n        } else {\n          x = elementName = xml.substring(i + 1, j);\n\n          tagStart = true;\n          tagEnd = false;\n        }\n\n        if (!(w > 96 && w < 123 || w > 64 && w < 91 || w === 95 || w === 58)) { // char 95\"_\" 58\":\"\n          return handleError('illegal first char nodeName');\n        }\n\n        for (q = 1, y = x.length; q < y; q++) {\n          w = x.charCodeAt(q);\n\n          if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 45 || w === 95 || w == 46) {\n            continue;\n          }\n\n          if (w === 32 || (w < 14 && w > 8)) { // \\f\\n\\r\\t\\v space\n            elementName = x.substring(0, q);\n\n            // maybe there are attributes\n            cachedAttrs = null;\n            break;\n          }\n\n          return handleError('invalid nodeName');\n        }\n\n        if (!tagEnd) {\n          nodeStack.push(elementName);\n        }\n      }\n\n      if (isNamespace) {\n\n        _nsMatrix = nsMatrix;\n\n        if (tagStart) {\n\n          // remember old namespace\n          // unless we're self-closing\n          if (!tagEnd) {\n            nsMatrixStack.push(_nsMatrix);\n          }\n\n          if (cachedAttrs === null) {\n\n            // quick check, whether there may be namespace\n            // declarations on the node; if that is the case\n            // we need to eagerly parse the node attributes\n            if ((maybeNS = x.indexOf('xmlns', q) !== -1)) {\n              attrsStart = q;\n              attrsString = x;\n\n              getAttrs();\n\n              maybeNS = false;\n            }\n          }\n        }\n\n        _elementName = elementName;\n\n        w = elementName.indexOf(':');\n        if (w !== -1) {\n          xmlns = nsMatrix[elementName.substring(0, w)];\n\n          // prefix given; namespace must exist\n          if (!xmlns) {\n            return handleError('missing namespace on <' + _elementName + '>');\n          }\n\n          elementName = elementName.substr(w + 1);\n        } else {\n          xmlns = nsMatrix['xmlns'];\n\n          // if no default namespace is defined,\n          // we'll import the element as anonymous.\n          //\n          // it is up to users to correct that to the document defined\n          // targetNamespace, or whatever their undersanding of the\n          // XML spec mandates.\n        }\n\n        // adjust namespace prefixs as configured\n        if (xmlns) {\n          elementName = xmlns + ':' + elementName;\n        }\n\n      }\n\n      if (tagStart) {\n        attrsStart = q;\n        attrsString = x;\n\n        if (onOpenTag) {\n          if (proxy) {\n            onOpenTag(elementProxy, decodeEntities, tagEnd, getContext);\n          } else {\n            onOpenTag(elementName, getAttrs, decodeEntities, tagEnd, getContext);\n          }\n\n          if (parseStop) {\n            return;\n          }\n        }\n\n      }\n\n      if (tagEnd) {\n\n        if (onCloseTag) {\n          onCloseTag(proxy ? elementProxy : elementName, decodeEntities, tagStart, getContext);\n\n          if (parseStop) {\n            return;\n          }\n        }\n\n        // restore old namespace\n        if (isNamespace) {\n          if (!tagStart) {\n            nsMatrix = nsMatrixStack.pop();\n          } else {\n            nsMatrix = _nsMatrix;\n          }\n        }\n      }\n\n      j += 1;\n    }\n  } /** end parse */\n\n}", "export function hasLowerCaseAlias(pkg) {\n  return pkg.xml && pkg.xml.tagAlias === 'lowerCase';\n}\n\nexport var DEFAULT_NS_MAP = {\n  'xsi': 'http://www.w3.org/2001/XMLSchema-instance',\n  'xml': 'http://www.w3.org/XML/1998/namespace'\n};\n\nexport var SERIALIZE_PROPERTY = 'property';\n\nexport function getSerialization(element) {\n  return element.xml && element.xml.serialize;\n}\n\nexport function getSerializationType(element) {\n  const type = getSerialization(element);\n\n  return type !== SERIALIZE_PROPERTY && (type || null);\n}", "import {\n  forEach,\n  find,\n  assign\n} from 'min-dash';\n\nimport {\n  Parser as SaxParser\n} from 'saxen';\n\nimport {\n  Moddle,\n  parseNameNS,\n  coerceType,\n  isSimpleType\n} from 'moddle';\n\nimport {\n  DEFAULT_NS_MAP,\n  getSerializationType,\n  hasLowerCaseAlias\n} from './common.js';\n\nfunction capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nfunction aliasToName(aliasNs, pkg) {\n\n  if (!hasLowerCaseAlias(pkg)) {\n    return aliasNs.name;\n  }\n\n  return aliasNs.prefix + ':' + capitalize(aliasNs.localName);\n}\n\n/**\n * Un-prefix a potentially prefixed type name.\n *\n * @param {NsName} nameNs\n * @param {Object} [pkg]\n *\n * @return {string}\n */\nfunction prefixedToName(nameNs, pkg) {\n\n  var name = nameNs.name,\n      localName = nameNs.localName;\n\n  var typePrefix = pkg && pkg.xml && pkg.xml.typePrefix;\n\n  if (typePrefix && localName.indexOf(typePrefix) === 0) {\n    return nameNs.prefix + ':' + localName.slice(typePrefix.length);\n  } else {\n    return name;\n  }\n}\n\nfunction normalizeTypeName(name, nsMap, model) {\n\n  // normalize against actual NS\n  const nameNs = parseNameNS(name, nsMap.xmlns);\n\n  const normalizedName = `${ nsMap[nameNs.prefix] || nameNs.prefix }:${ nameNs.localName }`;\n\n  const normalizedNameNs = parseNameNS(normalizedName);\n\n  // determine actual type name, based on package-defined prefix\n  var pkg = model.getPackage(normalizedNameNs.prefix);\n\n  return prefixedToName(normalizedNameNs, pkg);\n}\n\nfunction error(message) {\n  return new Error(message);\n}\n\n/**\n * Get the moddle descriptor for a given instance or type.\n *\n * @param  {ModdleElement|Function} element\n *\n * @return {Object} the moddle descriptor\n */\nfunction getModdleDescriptor(element) {\n  return element.$descriptor;\n}\n\n\n/**\n * A parse context.\n *\n * @class\n *\n * @param {Object} options\n * @param {ElementHandler} options.rootHandler the root handler for parsing a document\n * @param {boolean} [options.lax=false] whether or not to ignore invalid elements\n */\nexport function Context(options) {\n\n  /**\n   * @property {ElementHandler} rootHandler\n   */\n\n  /**\n   * @property {Boolean} lax\n   */\n\n  assign(this, options);\n\n  this.elementsById = {};\n  this.references = [];\n  this.warnings = [];\n\n  /**\n   * Add an unresolved reference.\n   *\n   * @param {Object} reference\n   */\n  this.addReference = function(reference) {\n    this.references.push(reference);\n  };\n\n  /**\n   * Add a processed element.\n   *\n   * @param {ModdleElement} element\n   */\n  this.addElement = function(element) {\n\n    if (!element) {\n      throw error('expected element');\n    }\n\n    var elementsById = this.elementsById;\n\n    var descriptor = getModdleDescriptor(element);\n\n    var idProperty = descriptor.idProperty,\n        id;\n\n    if (idProperty) {\n      id = element.get(idProperty.name);\n\n      if (id) {\n\n        // for QName validation as per http://www.w3.org/TR/REC-xml/#NT-NameChar\n        if (!/^([a-z][\\w-.]*:)?[a-z_][\\w-.]*$/i.test(id)) {\n          throw new Error('illegal ID <' + id + '>');\n        }\n\n        if (elementsById[id]) {\n          throw error('duplicate ID <' + id + '>');\n        }\n\n        elementsById[id] = element;\n      }\n    }\n  };\n\n  /**\n   * Add an import warning.\n   *\n   * @param {Object} warning\n   * @param {String} warning.message\n   * @param {Error} [warning.error]\n   */\n  this.addWarning = function(warning) {\n    this.warnings.push(warning);\n  };\n}\n\nfunction BaseHandler() {}\n\nBaseHandler.prototype.handleEnd = function() {};\nBaseHandler.prototype.handleText = function() {};\nBaseHandler.prototype.handleNode = function() {};\n\n\n/**\n * A simple pass through handler that does nothing except for\n * ignoring all input it receives.\n *\n * This is used to ignore unknown elements and\n * attributes.\n */\nfunction NoopHandler() { }\n\nNoopHandler.prototype = Object.create(BaseHandler.prototype);\n\nNoopHandler.prototype.handleNode = function() {\n  return this;\n};\n\nfunction BodyHandler() {}\n\nBodyHandler.prototype = Object.create(BaseHandler.prototype);\n\nBodyHandler.prototype.handleText = function(text) {\n  this.body = (this.body || '') + text;\n};\n\nfunction ReferenceHandler(property, context) {\n  this.property = property;\n  this.context = context;\n}\n\nReferenceHandler.prototype = Object.create(BodyHandler.prototype);\n\nReferenceHandler.prototype.handleNode = function(node) {\n\n  if (this.element) {\n    throw error('expected no sub nodes');\n  } else {\n    this.element = this.createReference(node);\n  }\n\n  return this;\n};\n\nReferenceHandler.prototype.handleEnd = function() {\n  this.element.id = this.body;\n};\n\nReferenceHandler.prototype.createReference = function(node) {\n  return {\n    property: this.property.ns.name,\n    id: ''\n  };\n};\n\nfunction ValueHandler(propertyDesc, element) {\n  this.element = element;\n  this.propertyDesc = propertyDesc;\n}\n\nValueHandler.prototype = Object.create(BodyHandler.prototype);\n\nValueHandler.prototype.handleEnd = function() {\n\n  var value = this.body || '',\n      element = this.element,\n      propertyDesc = this.propertyDesc;\n\n  value = coerceType(propertyDesc.type, value);\n\n  if (propertyDesc.isMany) {\n    element.get(propertyDesc.name).push(value);\n  } else {\n    element.set(propertyDesc.name, value);\n  }\n};\n\n\nfunction BaseElementHandler() {}\n\nBaseElementHandler.prototype = Object.create(BodyHandler.prototype);\n\nBaseElementHandler.prototype.handleNode = function(node) {\n  var parser = this,\n      element = this.element;\n\n  if (!element) {\n    element = this.element = this.createElement(node);\n\n    this.context.addElement(element);\n  } else {\n    parser = this.handleChild(node);\n  }\n\n  return parser;\n};\n\n/**\n * @class Reader.ElementHandler\n *\n */\nexport function ElementHandler(model, typeName, context) {\n  this.model = model;\n  this.type = model.getType(typeName);\n  this.context = context;\n}\n\nElementHandler.prototype = Object.create(BaseElementHandler.prototype);\n\nElementHandler.prototype.addReference = function(reference) {\n  this.context.addReference(reference);\n};\n\nElementHandler.prototype.handleText = function(text) {\n\n  var element = this.element,\n      descriptor = getModdleDescriptor(element),\n      bodyProperty = descriptor.bodyProperty;\n\n  if (!bodyProperty) {\n    throw error('unexpected body text <' + text + '>');\n  }\n\n  BodyHandler.prototype.handleText.call(this, text);\n};\n\nElementHandler.prototype.handleEnd = function() {\n\n  var value = this.body,\n      element = this.element,\n      descriptor = getModdleDescriptor(element),\n      bodyProperty = descriptor.bodyProperty;\n\n  if (bodyProperty && value !== undefined) {\n    value = coerceType(bodyProperty.type, value);\n    element.set(bodyProperty.name, value);\n  }\n};\n\n/**\n * Create an instance of the model from the given node.\n *\n * @param  {Element} node the xml node\n */\nElementHandler.prototype.createElement = function(node) {\n  var attributes = node.attributes,\n      Type = this.type,\n      descriptor = getModdleDescriptor(Type),\n      context = this.context,\n      instance = new Type({}),\n      model = this.model,\n      propNameNs;\n\n  forEach(attributes, function(value, name) {\n\n    var prop = descriptor.propertiesByName[name],\n        values;\n\n    if (prop && prop.isReference) {\n\n      if (!prop.isMany) {\n        context.addReference({\n          element: instance,\n          property: prop.ns.name,\n          id: value\n        });\n      } else {\n\n        // IDREFS: parse references as whitespace-separated list\n        values = value.split(' ');\n\n        forEach(values, function(v) {\n          context.addReference({\n            element: instance,\n            property: prop.ns.name,\n            id: v\n          });\n        });\n      }\n\n    } else {\n      if (prop) {\n        value = coerceType(prop.type, value);\n      } else if (name === 'xmlns') {\n        name = ':' + name;\n      } else {\n        propNameNs = parseNameNS(name, descriptor.ns.prefix);\n\n        // check whether attribute is defined in a well-known namespace\n        // if that is the case we emit a warning to indicate potential misuse\n        if (model.getPackage(propNameNs.prefix)) {\n\n          context.addWarning({\n            message: 'unknown attribute <' + name + '>',\n            element: instance,\n            property: name,\n            value: value\n          });\n        }\n      }\n\n      instance.set(name, value);\n    }\n  });\n\n  return instance;\n};\n\nElementHandler.prototype.getPropertyForNode = function(node) {\n\n  var name = node.name;\n  var nameNs = parseNameNS(name);\n\n  var type = this.type,\n      model = this.model,\n      descriptor = getModdleDescriptor(type);\n\n  var propertyName = nameNs.name,\n      property = descriptor.propertiesByName[propertyName];\n\n  // search for properties by name first\n\n  if (property && !property.isAttr) {\n\n    const serializationType = getSerializationType(property);\n\n    if (serializationType) {\n      const elementTypeName = node.attributes[serializationType];\n\n      // type is optional, if it does not exists the\n      // default type is assumed\n      if (elementTypeName) {\n\n        // convert the prefix used to the mapped form, but also\n        // take possible type prefixes from XML\n        // into account, i.e.: xsi:type=\"t{ActualType}\",\n        const normalizedTypeName = normalizeTypeName(elementTypeName, node.ns, model);\n\n        const elementType = model.getType(normalizedTypeName);\n\n        return assign({}, property, {\n          effectiveType: getModdleDescriptor(elementType).name\n        });\n      }\n    }\n\n    // search for properties by name first\n    return property;\n  }\n\n  var pkg = model.getPackage(nameNs.prefix);\n\n  if (pkg) {\n    const elementTypeName = aliasToName(nameNs, pkg);\n    const elementType = model.getType(elementTypeName);\n\n    // search for collection members later\n    property = find(descriptor.properties, function(p) {\n      return !p.isVirtual && !p.isReference && !p.isAttribute && elementType.hasType(p.type);\n    });\n\n    if (property) {\n      return assign({}, property, {\n        effectiveType: getModdleDescriptor(elementType).name\n      });\n    }\n  } else {\n\n    // parse unknown element (maybe extension)\n    property = find(descriptor.properties, function(p) {\n      return !p.isReference && !p.isAttribute && p.type === 'Element';\n    });\n\n    if (property) {\n      return property;\n    }\n  }\n\n  throw error('unrecognized element <' + nameNs.name + '>');\n};\n\nElementHandler.prototype.toString = function() {\n  return 'ElementDescriptor[' + getModdleDescriptor(this.type).name + ']';\n};\n\nElementHandler.prototype.valueHandler = function(propertyDesc, element) {\n  return new ValueHandler(propertyDesc, element);\n};\n\nElementHandler.prototype.referenceHandler = function(propertyDesc) {\n  return new ReferenceHandler(propertyDesc, this.context);\n};\n\nElementHandler.prototype.handler = function(type) {\n  if (type === 'Element') {\n    return new GenericElementHandler(this.model, type, this.context);\n  } else {\n    return new ElementHandler(this.model, type, this.context);\n  }\n};\n\n/**\n * Handle the child element parsing\n *\n * @param  {Element} node the xml node\n */\nElementHandler.prototype.handleChild = function(node) {\n  var propertyDesc, type, element, childHandler;\n\n  propertyDesc = this.getPropertyForNode(node);\n  element = this.element;\n\n  type = propertyDesc.effectiveType || propertyDesc.type;\n\n  if (isSimpleType(type)) {\n    return this.valueHandler(propertyDesc, element);\n  }\n\n  if (propertyDesc.isReference) {\n    childHandler = this.referenceHandler(propertyDesc).handleNode(node);\n  } else {\n    childHandler = this.handler(type).handleNode(node);\n  }\n\n  var newElement = childHandler.element;\n\n  // child handles may decide to skip elements\n  // by not returning anything\n  if (newElement !== undefined) {\n\n    if (propertyDesc.isMany) {\n      element.get(propertyDesc.name).push(newElement);\n    } else {\n      element.set(propertyDesc.name, newElement);\n    }\n\n    if (propertyDesc.isReference) {\n      assign(newElement, {\n        element: element\n      });\n\n      this.context.addReference(newElement);\n    } else {\n\n      // establish child -> parent relationship\n      newElement.$parent = element;\n    }\n  }\n\n  return childHandler;\n};\n\n/**\n * An element handler that performs special validation\n * to ensure the node it gets initialized with matches\n * the handlers type (namespace wise).\n *\n * @param {Moddle} model\n * @param {String} typeName\n * @param {Context} context\n */\nfunction RootElementHandler(model, typeName, context) {\n  ElementHandler.call(this, model, typeName, context);\n}\n\nRootElementHandler.prototype = Object.create(ElementHandler.prototype);\n\nRootElementHandler.prototype.createElement = function(node) {\n\n  var name = node.name,\n      nameNs = parseNameNS(name),\n      model = this.model,\n      type = this.type,\n      pkg = model.getPackage(nameNs.prefix),\n      typeName = pkg && aliasToName(nameNs, pkg) || name;\n\n  // verify the correct namespace if we parse\n  // the first element in the handler tree\n  //\n  // this ensures we don't mistakenly import wrong namespace elements\n  if (!type.hasType(typeName)) {\n    throw error('unexpected element <' + node.originalName + '>');\n  }\n\n  return ElementHandler.prototype.createElement.call(this, node);\n};\n\n\nfunction GenericElementHandler(model, typeName, context) {\n  this.model = model;\n  this.context = context;\n}\n\nGenericElementHandler.prototype = Object.create(BaseElementHandler.prototype);\n\nGenericElementHandler.prototype.createElement = function(node) {\n\n  var name = node.name,\n      ns = parseNameNS(name),\n      prefix = ns.prefix,\n      uri = node.ns[prefix + '$uri'],\n      attributes = node.attributes;\n\n  return this.model.createAny(name, uri, attributes);\n};\n\nGenericElementHandler.prototype.handleChild = function(node) {\n\n  var handler = new GenericElementHandler(this.model, 'Element', this.context).handleNode(node),\n      element = this.element;\n\n  var newElement = handler.element,\n      children;\n\n  if (newElement !== undefined) {\n    children = element.$children = element.$children || [];\n    children.push(newElement);\n\n    // establish child -> parent relationship\n    newElement.$parent = element;\n  }\n\n  return handler;\n};\n\nGenericElementHandler.prototype.handleEnd = function() {\n  if (this.body) {\n    this.element.$body = this.body;\n  }\n};\n\n/**\n * A reader for a meta-model\n *\n * @param {Object} options\n * @param {Model} options.model used to read xml files\n * @param {Boolean} options.lax whether to make parse errors warnings\n */\nexport function Reader(options) {\n\n  if (options instanceof Moddle) {\n    options = {\n      model: options\n    };\n  }\n\n  assign(this, { lax: false }, options);\n}\n\n/**\n * The fromXML result.\n *\n * @typedef {Object} ParseResult\n *\n * @property {ModdleElement} rootElement\n * @property {Array<Object>} references\n * @property {Array<Error>} warnings\n * @property {Object} elementsById - a mapping containing each ID -> ModdleElement\n */\n\n/**\n * The fromXML result.\n *\n * @typedef {Error} ParseError\n *\n * @property {Array<Error>} warnings\n */\n\n/**\n * Parse the given XML into a moddle document tree.\n *\n * @param {String} xml\n * @param {ElementHandler|Object} options or rootHandler\n *\n * @returns {Promise<ParseResult, ParseError>}\n */\nReader.prototype.fromXML = function(xml, options, done) {\n\n  var rootHandler = options.rootHandler;\n\n  if (options instanceof ElementHandler) {\n\n    // root handler passed via (xml, { rootHandler: ElementHandler }, ...)\n    rootHandler = options;\n    options = {};\n  } else {\n    if (typeof options === 'string') {\n\n      // rootHandler passed via (xml, 'someString', ...)\n      rootHandler = this.handler(options);\n      options = {};\n    } else if (typeof rootHandler === 'string') {\n\n      // rootHandler passed via (xml, { rootHandler: 'someString' }, ...)\n      rootHandler = this.handler(rootHandler);\n    }\n  }\n\n  var model = this.model,\n      lax = this.lax;\n\n  var context = new Context(assign({}, options, { rootHandler: rootHandler })),\n      parser = new SaxParser({ proxy: true }),\n      stack = createStack();\n\n  rootHandler.context = context;\n\n  // push root handler\n  stack.push(rootHandler);\n\n\n  /**\n   * Handle error.\n   *\n   * @param  {Error} err\n   * @param  {Function} getContext\n   * @param  {boolean} lax\n   *\n   * @return {boolean} true if handled\n   */\n  function handleError(err, getContext, lax) {\n\n    var ctx = getContext();\n\n    var line = ctx.line,\n        column = ctx.column,\n        data = ctx.data;\n\n    // we receive the full context data here,\n    // for elements trim down the information\n    // to the tag name, only\n    if (data.charAt(0) === '<' && data.indexOf(' ') !== -1) {\n      data = data.slice(0, data.indexOf(' ')) + '>';\n    }\n\n    var message =\n      'unparsable content ' + (data ? data + ' ' : '') + 'detected\\n\\t' +\n        'line: ' + line + '\\n\\t' +\n        'column: ' + column + '\\n\\t' +\n        'nested error: ' + err.message;\n\n    if (lax) {\n      context.addWarning({\n        message: message,\n        error: err\n      });\n\n      return true;\n    } else {\n      throw error(message);\n    }\n  }\n\n  function handleWarning(err, getContext) {\n\n    // just like handling errors in <lax=true> mode\n    return handleError(err, getContext, true);\n  }\n\n  /**\n   * Resolve collected references on parse end.\n   */\n  function resolveReferences() {\n\n    var elementsById = context.elementsById;\n    var references = context.references;\n\n    var i, r;\n\n    for (i = 0; (r = references[i]); i++) {\n      var element = r.element;\n      var reference = elementsById[r.id];\n      var property = getModdleDescriptor(element).propertiesByName[r.property];\n\n      if (!reference) {\n        context.addWarning({\n          message: 'unresolved reference <' + r.id + '>',\n          element: r.element,\n          property: r.property,\n          value: r.id\n        });\n      }\n\n      if (property.isMany) {\n        var collection = element.get(property.name),\n            idx = collection.indexOf(r);\n\n        // we replace an existing place holder (idx != -1) or\n        // append to the collection instead\n        if (idx === -1) {\n          idx = collection.length;\n        }\n\n        if (!reference) {\n\n          // remove unresolvable reference\n          collection.splice(idx, 1);\n        } else {\n\n          // add or update reference in collection\n          collection[idx] = reference;\n        }\n      } else {\n        element.set(property.name, reference);\n      }\n    }\n  }\n\n  function handleClose() {\n    stack.pop().handleEnd();\n  }\n\n  var PREAMBLE_START_PATTERN = /^<\\?xml /i;\n\n  var ENCODING_PATTERN = / encoding=\"([^\"]+)\"/i;\n\n  var UTF_8_PATTERN = /^utf-8$/i;\n\n  function handleQuestion(question) {\n\n    if (!PREAMBLE_START_PATTERN.test(question)) {\n      return;\n    }\n\n    var match = ENCODING_PATTERN.exec(question);\n    var encoding = match && match[1];\n\n    if (!encoding || UTF_8_PATTERN.test(encoding)) {\n      return;\n    }\n\n    context.addWarning({\n      message:\n        'unsupported document encoding <' + encoding + '>, ' +\n        'falling back to UTF-8'\n    });\n  }\n\n  function handleOpen(node, getContext) {\n    var handler = stack.peek();\n\n    try {\n      stack.push(handler.handleNode(node));\n    } catch (err) {\n\n      if (handleError(err, getContext, lax)) {\n        stack.push(new NoopHandler());\n      }\n    }\n  }\n\n  function handleCData(text, getContext) {\n\n    try {\n      stack.peek().handleText(text);\n    } catch (err) {\n      handleWarning(err, getContext);\n    }\n  }\n\n  function handleText(text, getContext) {\n\n    // strip whitespace only nodes, i.e. before\n    // <!CDATA[ ... ]> sections and in between tags\n\n    if (!text.trim()) {\n      return;\n    }\n\n    handleCData(text, getContext);\n  }\n\n  var uriMap = model.getPackages().reduce(function(uriMap, p) {\n    uriMap[p.uri] = p.prefix;\n\n    return uriMap;\n  }, Object.entries(DEFAULT_NS_MAP).reduce(function(map, [ prefix, url ]) {\n    map[url] = prefix;\n\n    return map;\n  }, model.config && model.config.nsMap || {}));\n\n  parser\n    .ns(uriMap)\n    .on('openTag', function(obj, decodeStr, selfClosing, getContext) {\n\n      // gracefully handle unparsable attributes (attrs=false)\n      var attrs = obj.attrs || {};\n\n      var decodedAttrs = Object.keys(attrs).reduce(function(d, key) {\n        var value = decodeStr(attrs[key]);\n\n        d[key] = value;\n\n        return d;\n      }, {});\n\n      var node = {\n        name: obj.name,\n        originalName: obj.originalName,\n        attributes: decodedAttrs,\n        ns: obj.ns\n      };\n\n      handleOpen(node, getContext);\n    })\n    .on('question', handleQuestion)\n    .on('closeTag', handleClose)\n    .on('cdata', handleCData)\n    .on('text', function(text, decodeEntities, getContext) {\n      handleText(decodeEntities(text), getContext);\n    })\n    .on('error', handleError)\n    .on('warn', handleWarning);\n\n  // async XML parsing to make sure the execution environment\n  // (node or brower) is kept responsive and that certain optimization\n  // strategies can kick in.\n  return new Promise(function(resolve, reject) {\n\n    var err;\n\n    try {\n      parser.parse(xml);\n\n      resolveReferences();\n    } catch (e) {\n      err = e;\n    }\n\n    var rootElement = rootHandler.element;\n\n    if (!err && !rootElement) {\n      err = error('failed to parse document as <' + rootHandler.type.$descriptor.name + '>');\n    }\n\n    var warnings = context.warnings;\n    var references = context.references;\n    var elementsById = context.elementsById;\n\n    if (err) {\n      err.warnings = warnings;\n\n      return reject(err);\n    } else {\n      return resolve({\n        rootElement: rootElement,\n        elementsById: elementsById,\n        references: references,\n        warnings: warnings\n      });\n    }\n  });\n};\n\nReader.prototype.handler = function(name) {\n  return new RootElementHandler(this.model, name);\n};\n\n\n// helpers //////////////////////////\n\nfunction createStack() {\n  var stack = [];\n\n  Object.defineProperty(stack, 'peek', {\n    value: function() {\n      return this[this.length - 1];\n    }\n  });\n\n  return stack;\n}\n", "import {\n  forEach,\n  isString,\n  filter,\n  assign,\n  has,\n  findIndex\n} from 'min-dash';\n\nimport {\n  isSimpleType,\n  parseNameNS\n} from 'moddle';\n\nimport {\n  hasLowerCaseAlias,\n  getSerialization,\n  SERIALIZE_PROPERTY,\n  DEFAULT_NS_MAP\n} from './common.js';\n\nvar XML_PREAMBLE = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n\nvar ESCAPE_ATTR_CHARS = /<|>|'|\"|&|\\n\\r|\\n/g;\nvar ESCAPE_CHARS = /<|>|&/g;\n\n\nexport function Namespaces(parent) {\n\n  this.prefixMap = {};\n  this.uriMap = {};\n  this.used = {};\n\n  this.wellknown = [];\n  this.custom = [];\n  this.parent = parent;\n\n  this.defaultPrefixMap = parent && parent.defaultPrefixMap || {};\n}\n\nNamespaces.prototype.mapDefaultPrefixes = function(defaultPrefixMap) {\n  this.defaultPrefixMap = defaultPrefixMap;\n};\n\nNamespaces.prototype.defaultUriByPrefix = function(prefix) {\n  return this.defaultPrefixMap[prefix];\n};\n\nNamespaces.prototype.byUri = function(uri) {\n  return this.uriMap[uri] || (\n    this.parent && this.parent.byUri(uri)\n  );\n};\n\nNamespaces.prototype.add = function(ns, isWellknown) {\n\n  this.uriMap[ns.uri] = ns;\n\n  if (isWellknown) {\n    this.wellknown.push(ns);\n  } else {\n    this.custom.push(ns);\n  }\n\n  this.mapPrefix(ns.prefix, ns.uri);\n};\n\nNamespaces.prototype.uriByPrefix = function(prefix) {\n  return this.prefixMap[prefix || 'xmlns'] || (\n    this.parent && this.parent.uriByPrefix(prefix)\n  );\n};\n\nNamespaces.prototype.mapPrefix = function(prefix, uri) {\n  this.prefixMap[prefix || 'xmlns'] = uri;\n};\n\nNamespaces.prototype.getNSKey = function(ns) {\n  return (ns.prefix !== undefined) ? (ns.uri + '|' + ns.prefix) : ns.uri;\n};\n\nNamespaces.prototype.logUsed = function(ns) {\n\n  var uri = ns.uri;\n  var nsKey = this.getNSKey(ns);\n\n  this.used[nsKey] = this.byUri(uri);\n\n  // Inform parent recursively about the usage of this NS\n  if (this.parent) {\n    this.parent.logUsed(ns);\n  }\n};\n\nNamespaces.prototype.getUsed = function(ns) {\n\n  var allNs = [].concat(this.wellknown, this.custom);\n\n  return allNs.filter(ns => {\n    var nsKey = this.getNSKey(ns);\n\n    return this.used[nsKey];\n  });\n};\n\n\nfunction lower(string) {\n  return string.charAt(0).toLowerCase() + string.slice(1);\n}\n\nfunction nameToAlias(name, pkg) {\n  if (hasLowerCaseAlias(pkg)) {\n    return lower(name);\n  } else {\n    return name;\n  }\n}\n\nfunction inherits(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object.create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n}\n\nfunction nsName(ns) {\n  if (isString(ns)) {\n    return ns;\n  } else {\n    return (ns.prefix ? ns.prefix + ':' : '') + ns.localName;\n  }\n}\n\nfunction getNsAttrs(namespaces) {\n\n  return namespaces.getUsed().filter(function(ns) {\n\n    // do not serialize built in <xml> namespace\n    return ns.prefix !== 'xml';\n  }).map(function(ns) {\n    var name = 'xmlns' + (ns.prefix ? ':' + ns.prefix : '');\n    return { name: name, value: ns.uri };\n  });\n\n}\n\nfunction getElementNs(ns, descriptor) {\n  if (descriptor.isGeneric) {\n    return assign({ localName: descriptor.ns.localName }, ns);\n  } else {\n    return assign({ localName: nameToAlias(descriptor.ns.localName, descriptor.$pkg) }, ns);\n  }\n}\n\nfunction getPropertyNs(ns, descriptor) {\n  return assign({ localName: descriptor.ns.localName }, ns);\n}\n\nfunction getSerializableProperties(element) {\n  var descriptor = element.$descriptor;\n\n  return filter(descriptor.properties, function(p) {\n    var name = p.name;\n\n    if (p.isVirtual) {\n      return false;\n    }\n\n    // do not serialize defaults\n    if (!has(element, name)) {\n      return false;\n    }\n\n    var value = element[name];\n\n    // do not serialize default equals\n    if (value === p.default) {\n      return false;\n    }\n\n    // do not serialize null properties\n    if (value === null) {\n      return false;\n    }\n\n    return p.isMany ? value.length : true;\n  });\n}\n\nvar ESCAPE_ATTR_MAP = {\n  '\\n': '#10',\n  '\\n\\r': '#10',\n  '\"': '#34',\n  '\\'': '#39',\n  '<': '#60',\n  '>': '#62',\n  '&': '#38'\n};\n\nvar ESCAPE_MAP = {\n  '<': 'lt',\n  '>': 'gt',\n  '&': 'amp'\n};\n\nfunction escape(str, charPattern, replaceMap) {\n\n  // ensure we are handling strings here\n  str = isString(str) ? str : '' + str;\n\n  return str.replace(charPattern, function(s) {\n    return '&' + replaceMap[s] + ';';\n  });\n}\n\n/**\n * Escape a string attribute to not contain any bad values (line breaks, '\"', ...)\n *\n * @param {String} str the string to escape\n * @return {String} the escaped string\n */\nfunction escapeAttr(str) {\n  return escape(str, ESCAPE_ATTR_CHARS, ESCAPE_ATTR_MAP);\n}\n\nfunction escapeBody(str) {\n  return escape(str, ESCAPE_CHARS, ESCAPE_MAP);\n}\n\nfunction filterAttributes(props) {\n  return filter(props, function(p) { return p.isAttr; });\n}\n\nfunction filterContained(props) {\n  return filter(props, function(p) { return !p.isAttr; });\n}\n\n\nfunction ReferenceSerializer(tagName) {\n  this.tagName = tagName;\n}\n\nReferenceSerializer.prototype.build = function(element) {\n  this.element = element;\n  return this;\n};\n\nReferenceSerializer.prototype.serializeTo = function(writer) {\n  writer\n    .appendIndent()\n    .append('<' + this.tagName + '>' + this.element.id + '</' + this.tagName + '>')\n    .appendNewLine();\n};\n\nfunction BodySerializer() {}\n\nBodySerializer.prototype.serializeValue =\nBodySerializer.prototype.serializeTo = function(writer) {\n  writer.append(\n    this.escape\n      ? escapeBody(this.value)\n      : this.value\n  );\n};\n\nBodySerializer.prototype.build = function(prop, value) {\n  this.value = value;\n\n  if (prop.type === 'String' && value.search(ESCAPE_CHARS) !== -1) {\n    this.escape = true;\n  }\n\n  return this;\n};\n\nfunction ValueSerializer(tagName) {\n  this.tagName = tagName;\n}\n\ninherits(ValueSerializer, BodySerializer);\n\nValueSerializer.prototype.serializeTo = function(writer) {\n\n  writer\n    .appendIndent()\n    .append('<' + this.tagName + '>');\n\n  this.serializeValue(writer);\n\n  writer\n    .append('</' + this.tagName + '>')\n    .appendNewLine();\n};\n\nfunction ElementSerializer(parent, propertyDescriptor) {\n  this.body = [];\n  this.attrs = [];\n\n  this.parent = parent;\n  this.propertyDescriptor = propertyDescriptor;\n}\n\nElementSerializer.prototype.build = function(element) {\n  this.element = element;\n\n  var elementDescriptor = element.$descriptor,\n      propertyDescriptor = this.propertyDescriptor;\n\n  var otherAttrs,\n      properties;\n\n  var isGeneric = elementDescriptor.isGeneric;\n\n  if (isGeneric) {\n    otherAttrs = this.parseGenericNsAttributes(element);\n  } else {\n    otherAttrs = this.parseNsAttributes(element);\n  }\n\n  if (propertyDescriptor) {\n    this.ns = this.nsPropertyTagName(propertyDescriptor);\n  } else {\n    this.ns = this.nsTagName(elementDescriptor);\n  }\n\n  // compute tag name\n  this.tagName = this.addTagName(this.ns);\n\n  if (isGeneric) {\n    this.parseGenericContainments(element);\n  } else {\n    properties = getSerializableProperties(element);\n\n    this.parseAttributes(filterAttributes(properties));\n    this.parseContainments(filterContained(properties));\n  }\n\n  this.parseGenericAttributes(element, otherAttrs);\n\n  return this;\n};\n\nElementSerializer.prototype.nsTagName = function(descriptor) {\n  var effectiveNs = this.logNamespaceUsed(descriptor.ns);\n  return getElementNs(effectiveNs, descriptor);\n};\n\nElementSerializer.prototype.nsPropertyTagName = function(descriptor) {\n  var effectiveNs = this.logNamespaceUsed(descriptor.ns);\n  return getPropertyNs(effectiveNs, descriptor);\n};\n\nElementSerializer.prototype.isLocalNs = function(ns) {\n  return ns.uri === this.ns.uri;\n};\n\n/**\n * Get the actual ns attribute name for the given element.\n *\n * @param {Object} element\n * @param {Boolean} [element.inherited=false]\n *\n * @return {Object} nsName\n */\nElementSerializer.prototype.nsAttributeName = function(element) {\n\n  var ns;\n\n  if (isString(element)) {\n    ns = parseNameNS(element);\n  } else {\n    ns = element.ns;\n  }\n\n  // return just local name for inherited attributes\n  if (element.inherited) {\n    return { localName: ns.localName };\n  }\n\n  // parse + log effective ns\n  var effectiveNs = this.logNamespaceUsed(ns);\n\n  // LOG ACTUAL namespace use\n  this.getNamespaces().logUsed(effectiveNs);\n\n  // strip prefix if same namespace like parent\n  if (this.isLocalNs(effectiveNs)) {\n    return { localName: ns.localName };\n  } else {\n    return assign({ localName: ns.localName }, effectiveNs);\n  }\n};\n\nElementSerializer.prototype.parseGenericNsAttributes = function(element) {\n\n  return Object.entries(element).filter(\n    ([ key, value ]) => !key.startsWith('$') && this.parseNsAttribute(element, key, value)\n  ).map(\n    ([ key, value ]) => ({ name: key, value: value })\n  );\n};\n\nElementSerializer.prototype.parseGenericContainments = function(element) {\n  var body = element.$body;\n\n  if (body) {\n    this.body.push(new BodySerializer().build({ type: 'String' }, body));\n  }\n\n  var children = element.$children;\n\n  if (children) {\n    forEach(children, child => {\n      this.body.push(new ElementSerializer(this).build(child));\n    });\n  }\n};\n\nElementSerializer.prototype.parseNsAttribute = function(element, name, value) {\n  var model = element.$model;\n\n  var nameNs = parseNameNS(name);\n\n  var ns;\n\n  // parse xmlns:foo=\"http://foo.bar\"\n  if (nameNs.prefix === 'xmlns') {\n    ns = { prefix: nameNs.localName, uri: value };\n  }\n\n  // parse xmlns=\"http://foo.bar\"\n  if (!nameNs.prefix && nameNs.localName === 'xmlns') {\n    ns = { uri: value };\n  }\n\n  if (!ns) {\n    return {\n      name: name,\n      value: value\n    };\n  }\n\n  if (model && model.getPackage(value)) {\n\n    // register well known namespace\n    this.logNamespace(ns, true, true);\n  } else {\n\n    // log custom namespace directly as used\n    var actualNs = this.logNamespaceUsed(ns, true);\n\n    this.getNamespaces().logUsed(actualNs);\n  }\n};\n\n\n/**\n * Parse namespaces and return a list of left over generic attributes\n *\n * @param  {Object} element\n * @return {Array<Object>}\n */\nElementSerializer.prototype.parseNsAttributes = function(element) {\n  var self = this;\n\n  var genericAttrs = element.$attrs;\n\n  var attributes = [];\n\n  // parse namespace attributes first\n  // and log them. push non namespace attributes to a list\n  // and process them later\n  forEach(genericAttrs, function(value, name) {\n\n    var nonNsAttr = self.parseNsAttribute(element, name, value);\n\n    if (nonNsAttr) {\n      attributes.push(nonNsAttr);\n    }\n  });\n\n  return attributes;\n};\n\nElementSerializer.prototype.parseGenericAttributes = function(element, attributes) {\n\n  var self = this;\n\n  forEach(attributes, function(attr) {\n\n    try {\n      self.addAttribute(self.nsAttributeName(attr.name), attr.value);\n    } catch (e) {\n\n      // eslint-disable-next-line no-undef\n      typeof console !== 'undefined' && console.warn(\n        `missing namespace information for <${\n          attr.name\n        }=${ attr.value }> on`, element, e\n      );\n    }\n  });\n};\n\nElementSerializer.prototype.parseContainments = function(properties) {\n\n  var self = this,\n      body = this.body,\n      element = this.element;\n\n  forEach(properties, function(p) {\n    var value = element.get(p.name),\n        isReference = p.isReference,\n        isMany = p.isMany;\n\n    if (!isMany) {\n      value = [ value ];\n    }\n\n    if (p.isBody) {\n      body.push(new BodySerializer().build(p, value[0]));\n    } else if (isSimpleType(p.type)) {\n      forEach(value, function(v) {\n        body.push(new ValueSerializer(self.addTagName(self.nsPropertyTagName(p))).build(p, v));\n      });\n    } else if (isReference) {\n      forEach(value, function(v) {\n        body.push(new ReferenceSerializer(self.addTagName(self.nsPropertyTagName(p))).build(v));\n      });\n    } else {\n\n      // allow serialization via type\n      // rather than element name\n      var serialization = getSerialization(p);\n\n      forEach(value, function(v) {\n        var serializer;\n\n        if (serialization) {\n          if (serialization === SERIALIZE_PROPERTY) {\n            serializer = new ElementSerializer(self, p);\n          } else {\n            serializer = new TypeSerializer(self, p, serialization);\n          }\n        } else {\n          serializer = new ElementSerializer(self);\n        }\n\n        body.push(serializer.build(v));\n      });\n    }\n  });\n};\n\nElementSerializer.prototype.getNamespaces = function(local) {\n\n  var namespaces = this.namespaces,\n      parent = this.parent,\n      parentNamespaces;\n\n  if (!namespaces) {\n    parentNamespaces = parent && parent.getNamespaces();\n\n    if (local || !parentNamespaces) {\n      this.namespaces = namespaces = new Namespaces(parentNamespaces);\n    } else {\n      namespaces = parentNamespaces;\n    }\n  }\n\n  return namespaces;\n};\n\nElementSerializer.prototype.logNamespace = function(ns, wellknown, local) {\n  var namespaces = this.getNamespaces(local);\n\n  var nsUri = ns.uri,\n      nsPrefix = ns.prefix;\n\n  var existing = namespaces.byUri(nsUri);\n\n  if (!existing || local) {\n    namespaces.add(ns, wellknown);\n  }\n\n  namespaces.mapPrefix(nsPrefix, nsUri);\n\n  return ns;\n};\n\nElementSerializer.prototype.logNamespaceUsed = function(ns, local) {\n  var namespaces = this.getNamespaces(local);\n\n  // ns may be\n  //\n  //   * prefix only\n  //   * prefix:uri\n  //   * localName only\n\n  var prefix = ns.prefix,\n      uri = ns.uri,\n      newPrefix, idx,\n      wellknownUri;\n\n  // handle anonymous namespaces (elementForm=unqualified), cf. #23\n  if (!prefix && !uri) {\n    return { localName: ns.localName };\n  }\n\n  wellknownUri = namespaces.defaultUriByPrefix(prefix);\n\n  uri = uri || wellknownUri || namespaces.uriByPrefix(prefix);\n\n  if (!uri) {\n    throw new Error('no namespace uri given for prefix <' + prefix + '>');\n  }\n\n  ns = namespaces.byUri(uri);\n\n  // register new default prefix <xmlns> in local scope\n  if (!ns && !prefix) {\n    ns = this.logNamespace({ uri }, wellknownUri === uri, true);\n  }\n\n  if (!ns) {\n    newPrefix = prefix;\n    idx = 1;\n\n    // find a prefix that is not mapped yet\n    while (namespaces.uriByPrefix(newPrefix)) {\n      newPrefix = prefix + '_' + idx++;\n    }\n\n    ns = this.logNamespace({ prefix: newPrefix, uri: uri }, wellknownUri === uri);\n  }\n\n  if (prefix) {\n    namespaces.mapPrefix(prefix, uri);\n  }\n\n  return ns;\n};\n\nElementSerializer.prototype.parseAttributes = function(properties) {\n  var self = this,\n      element = this.element;\n\n  forEach(properties, function(p) {\n\n    var value = element.get(p.name);\n\n    if (p.isReference) {\n\n      if (!p.isMany) {\n        value = value.id;\n      } else {\n        var values = [];\n        forEach(value, function(v) {\n          values.push(v.id);\n        });\n\n        // IDREFS is a whitespace-separated list of references.\n        value = values.join(' ');\n      }\n\n    }\n\n    self.addAttribute(self.nsAttributeName(p), value);\n  });\n};\n\nElementSerializer.prototype.addTagName = function(nsTagName) {\n  var actualNs = this.logNamespaceUsed(nsTagName);\n\n  this.getNamespaces().logUsed(actualNs);\n\n  return nsName(nsTagName);\n};\n\nElementSerializer.prototype.addAttribute = function(name, value) {\n  var attrs = this.attrs;\n\n  if (isString(value)) {\n    value = escapeAttr(value);\n  }\n\n  // de-duplicate attributes\n  // https://github.com/bpmn-io/moddle-xml/issues/66\n  var idx = findIndex(attrs, function(element) {\n    return (\n      element.name.localName === name.localName &&\n      element.name.uri === name.uri &&\n      element.name.prefix === name.prefix\n    );\n  });\n\n  var attr = { name: name, value: value };\n\n  if (idx !== -1) {\n    attrs.splice(idx, 1, attr);\n  } else {\n    attrs.push(attr);\n  }\n};\n\nElementSerializer.prototype.serializeAttributes = function(writer) {\n  var attrs = this.attrs,\n      namespaces = this.namespaces;\n\n  if (namespaces) {\n    attrs = getNsAttrs(namespaces).concat(attrs);\n  }\n\n  forEach(attrs, function(a) {\n    writer\n      .append(' ')\n      .append(nsName(a.name)).append('=\"').append(a.value).append('\"');\n  });\n};\n\nElementSerializer.prototype.serializeTo = function(writer) {\n  var firstBody = this.body[0],\n      indent = firstBody && firstBody.constructor !== BodySerializer;\n\n  writer\n    .appendIndent()\n    .append('<' + this.tagName);\n\n  this.serializeAttributes(writer);\n\n  writer.append(firstBody ? '>' : ' />');\n\n  if (firstBody) {\n\n    if (indent) {\n      writer\n        .appendNewLine()\n        .indent();\n    }\n\n    forEach(this.body, function(b) {\n      b.serializeTo(writer);\n    });\n\n    if (indent) {\n      writer\n        .unindent()\n        .appendIndent();\n    }\n\n    writer.append('</' + this.tagName + '>');\n  }\n\n  writer.appendNewLine();\n};\n\n/**\n * A serializer for types that handles serialization of data types\n */\nfunction TypeSerializer(parent, propertyDescriptor, serialization) {\n  ElementSerializer.call(this, parent, propertyDescriptor);\n\n  this.serialization = serialization;\n}\n\ninherits(TypeSerializer, ElementSerializer);\n\nTypeSerializer.prototype.parseNsAttributes = function(element) {\n\n  // extracted attributes with serialization attribute\n  // <type=typeName> stripped; it may be later\n  var attributes = ElementSerializer.prototype.parseNsAttributes.call(this, element).filter(\n    attr => attr.name !== this.serialization\n  );\n\n  var descriptor = element.$descriptor;\n\n  // only serialize <type=typeName> if necessary\n  if (descriptor.name === this.propertyDescriptor.type) {\n    return attributes;\n  }\n\n  var typeNs = this.typeNs = this.nsTagName(descriptor);\n  this.getNamespaces().logUsed(this.typeNs);\n\n  // add xsi:type attribute to represent the elements\n  // actual type\n\n  var pkg = element.$model.getPackage(typeNs.uri),\n      typePrefix = (pkg.xml && pkg.xml.typePrefix) || '';\n\n  this.addAttribute(\n    this.nsAttributeName(this.serialization),\n    (typeNs.prefix ? typeNs.prefix + ':' : '') + typePrefix + descriptor.ns.localName\n  );\n\n  return attributes;\n};\n\nTypeSerializer.prototype.isLocalNs = function(ns) {\n  return ns.uri === (this.typeNs || this.ns).uri;\n};\n\nfunction SavingWriter() {\n  this.value = '';\n\n  this.write = function(str) {\n    this.value += str;\n  };\n}\n\nfunction FormatingWriter(out, format) {\n\n  var indent = [ '' ];\n\n  this.append = function(str) {\n    out.write(str);\n\n    return this;\n  };\n\n  this.appendNewLine = function() {\n    if (format) {\n      out.write('\\n');\n    }\n\n    return this;\n  };\n\n  this.appendIndent = function() {\n    if (format) {\n      out.write(indent.join('  '));\n    }\n\n    return this;\n  };\n\n  this.indent = function() {\n    indent.push('');\n    return this;\n  };\n\n  this.unindent = function() {\n    indent.pop();\n    return this;\n  };\n}\n\n/**\n * A writer for meta-model backed document trees\n *\n * @param {Object} options output options to pass into the writer\n */\nexport function Writer(options) {\n\n  options = assign({ format: false, preamble: true }, options || {});\n\n  function toXML(tree, writer) {\n    var internalWriter = writer || new SavingWriter();\n    var formatingWriter = new FormatingWriter(internalWriter, options.format);\n\n    if (options.preamble) {\n      formatingWriter.append(XML_PREAMBLE);\n    }\n\n    var serializer = new ElementSerializer();\n\n    var model = tree.$model;\n\n    serializer.getNamespaces().mapDefaultPrefixes(getDefaultPrefixMappings(model));\n\n    serializer.build(tree).serializeTo(formatingWriter);\n\n    if (!writer) {\n      return internalWriter.value;\n    }\n  }\n\n  return {\n    toXML: toXML\n  };\n}\n\n\n// helpers ///////////\n\n/**\n * @param {Moddle} model\n *\n * @return { Record<string, string> } map from prefix to URI\n */\nfunction getDefaultPrefixMappings(model) {\n\n  const nsMap = model.config && model.config.nsMap || {};\n\n  const prefixMap = {};\n\n  // { prefix -> uri }\n  for (const prefix in DEFAULT_NS_MAP) {\n    prefixMap[prefix] = DEFAULT_NS_MAP[prefix];\n  }\n\n  // { uri -> prefix }\n  for (const uri in nsMap) {\n    const prefix = nsMap[uri];\n\n    prefixMap[prefix] = uri;\n  }\n\n  for (const pkg of model.getPackages()) {\n    prefixMap[pkg.prefix] = pkg.uri;\n  }\n\n  return prefixMap;\n}", "import {\n  isString,\n  assign\n} from 'min-dash';\n\nimport {\n  Moddle\n} from 'moddle';\n\nimport {\n  Reader,\n  Writer\n} from 'moddle-xml';\n\n\n/**\n * A sub class of {@link Moddle} with support for import and export of BPMN 2.0 xml files.\n *\n * @class BpmnModdle\n * @extends Moddle\n *\n * @param {Object|Array} packages to use for instantiating the model\n * @param {Object} [options] additional options to pass over\n */\nexport default function BpmnModdle(packages, options) {\n  Moddle.call(this, packages, options);\n}\n\nBpmnModdle.prototype = Object.create(Moddle.prototype);\n\n/**\n * The fromXML result.\n *\n * @typedef {Object} ParseResult\n *\n * @property {ModdleElement} rootElement\n * @property {Array<Object>} references\n * @property {Array<Error>} warnings\n * @property {Object} elementsById - a mapping containing each ID -> ModdleElement\n */\n\n/**\n * The fromXML error.\n *\n * @typedef {Error} ParseError\n *\n * @property {Array<Error>} warnings\n */\n\n/**\n * Instantiates a BPMN model tree from a given xml string.\n *\n * @param {String}   xmlStr\n * @param {String}   [typeName='bpmn:Definitions'] name of the root element\n * @param {Object}   [options]  options to pass to the underlying reader\n *\n * @returns {Promise<ParseResult, ParseError>}\n */\nBpmnModdle.prototype.fromXML = function(xmlStr, typeName, options) {\n\n  if (!isString(typeName)) {\n    options = typeName;\n    typeName = 'bpmn:Definitions';\n  }\n\n  var reader = new Reader(assign({ model: this, lax: true }, options));\n  var rootHandler = reader.handler(typeName);\n\n  return reader.fromXML(xmlStr, rootHandler);\n};\n\n\n/**\n * The toXML result.\n *\n * @typedef {Object} SerializationResult\n *\n * @property {String} xml\n */\n\n/**\n * Serializes a BPMN 2.0 object tree to XML.\n *\n * @param {String}   element    the root element, typically an instance of `bpmn:Definitions`\n * @param {Object}   [options]  to pass to the underlying writer\n *\n * @returns {Promise<SerializationResult, Error>}\n */\nBpmnModdle.prototype.toXML = function(element, options) {\n\n  var writer = new Writer(options);\n\n  return new Promise(function(resolve, reject) {\n    try {\n      var result = writer.toXML(element);\n\n      return resolve({\n        xml: result\n      });\n    } catch (err) {\n      return reject(err);\n    }\n  });\n};\n", "import {\n  assign\n} from 'min-dash';\n\nimport BpmnModdle from './bpmn-moddle.js';\n\nimport BpmnPackage from '../resources/bpmn/json/bpmn.json' with { type: 'json' };\nimport BpmnDiPackage from '../resources/bpmn/json/bpmndi.json' with { type: 'json' };\nimport DcPackage from '../resources/bpmn/json/dc.json' with { type: 'json' };\nimport DiPackage from '../resources/bpmn/json/di.json' with { type: 'json' };\nimport BiocPackage from '../resources/bpmn-io/json/bioc.json' with { type: 'json' };\nimport BpmnInColorPackage from 'bpmn-in-color-moddle/resources/bpmn-in-color.json' with { type: 'json' };\n\nconst packages = {\n  bpmn: BpmnPackage,\n  bpmndi: BpmnDiPackage,\n  dc: DcPackage,\n  di: DiPackage,\n  bioc: BiocPackage,\n  color: BpmnInColorPackage\n};\n\nexport default function SimpleBpmnModdle(additionalPackages, options) {\n  const pks = assign({}, packages, additionalPackages);\n\n  return new BpmnModdle(pks, options);\n}\n"],
  "mappings": "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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1FA,IAAM,WAAW;EACf,MAAM;EACN,QAAQ;EACR,IAAI;EACJ,IAAI;EACJ,MAAM;EACN,OAAO;AACT;AAEe,SAAS,iBAAiB,oBAAoB,SAAS;AACpE,QAAM,MAAM,OAAO,CAAA,GAAI,UAAU,kBAAkB;AAEnD,SAAO,IAAI,WAAW,KAAK,OAAO;AACpC;",
  "names": ["timeout", "name", "prefix", "parseNameNs", "types", "packages", "isBuiltInType", "nsName", "trait", "isUndefined", "error", "prefix", "uri", "name", "xml", "nsName", "i", "w", "j", "name", "error", "prefix", "uri", "xml", "SaxParser", "lax", "uriMap", "map", "decodeEntities", "ns", "packages"]
}
